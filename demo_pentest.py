#!/usr/bin/env python3
"""
Demo script showing the Aider Pentesting Agent capabilities.
This script demonstrates all the key features without requiring full dependencies.
"""

import asyncio
import json
import sys
from pathlib import Path

# Add the project root to path
sys.path.insert(0, str(Path(__file__).parent))

async def demo_configuration():
    """Demonstrate configuration management."""
    print("üîß Configuration Management Demo")
    print("=" * 50)
    
    from aider.pentest.config import PentestConfig
    
    # Create default configuration
    config = PentestConfig()
    print(f"‚úÖ Created default configuration with {len(config.llm_providers)} LLM providers")
    
    # Show LLM providers
    for provider in config.llm_providers:
        status = "‚úÖ Enabled" if provider.enabled else "‚ùå Disabled"
        print(f"   {provider.name}: {provider.model} {status}")
    
    # Show security settings
    sec = config.security_config
    print(f"‚úÖ Security: Zero-trust={sec.enforce_zero_trust}, Consent={sec.require_consent}, Audit={sec.audit_log_enabled}")
    
    # Show report formats
    print(f"‚úÖ Report formats: {', '.join(config.report_formats)}")
    
    # Demonstrate serialization
    config_dict = config.to_dict()
    new_config = PentestConfig.from_dict(config_dict)
    print("‚úÖ Configuration serialization/deserialization working")
    
    print()


async def demo_workflows():
    """Demonstrate workflow management."""
    print("üîÑ Workflow Management Demo")
    print("=" * 50)
    
    from aider.pentest.workflows.manager import WorkflowManager
    from aider.pentest.config import PentestConfig
    
    config = PentestConfig()
    wm = WorkflowManager(config)
    
    # List available templates
    templates = await wm.list_templates()
    print(f"‚úÖ Available workflow templates:")
    print(f"   Built-in: {', '.join(templates['builtin'])}")
    print(f"   Demo: {', '.join(templates['demo'])}")
    
    # Create workflows
    web_workflow = await wm.create_workflow("web")
    print(f"‚úÖ Created web workflow: {web_workflow['name']} with {len(web_workflow['phases'])} phases")
    
    network_workflow = await wm.create_workflow("network")
    print(f"‚úÖ Created network workflow: {network_workflow['name']} with {len(network_workflow['phases'])} phases")
    
    # Load demo template
    juice_shop = await wm.load_template("juice_shop")
    print(f"‚úÖ Loaded demo template: {juice_shop['name']} for {juice_shop['domain']} testing")
    
    # Validate template
    errors = await wm.validate_template(web_workflow)
    print(f"‚úÖ Template validation: {len(errors)} errors (should be 0)")
    
    print()


async def demo_vulnerability_intel():
    """Demonstrate vulnerability intelligence."""
    print("üß† Vulnerability Intelligence Demo")
    print("=" * 50)
    
    from aider.pentest.intel.vulnerability import VulnerabilityIntel
    from aider.pentest.config import PentestConfig
    
    config = PentestConfig()
    intel = VulnerabilityIntel(config)
    
    # Initialize intelligence
    await intel.initialize()
    print(f"‚úÖ Initialized vulnerability database with {len(intel.cve_cache)} CVEs")
    print(f"‚úÖ Exploit database contains {len(intel.exploit_db)} exploit mappings")
    
    # Show sample CVEs
    sample_cves = list(intel.cve_cache.keys())[:3]
    for cve in sample_cves:
        data = intel.cve_cache[cve]
        print(f"   {cve}: CVSS {data['cvss_v3_score']}/10, {data['severity']}")
    
    # Demonstrate finding enrichment
    test_findings = {
        "target": "demo.example.com",
        "phases": [{
            "name": "vulnerability_scan",
            "task_results": [{
                "findings": [
                    {"cve": "CVE-2021-44228", "service": "apache", "version": "2.4.6"},
                    {"cve": "CVE-2020-1472", "service": "smb", "version": "unknown"}
                ]
            }]
        }]
    }
    
    enriched = await intel.enrich_findings(test_findings)
    
    print("‚úÖ Enriched findings with intelligence:")
    for finding in enriched["phases"][0]["task_results"][0]["findings"]:
        cve = finding.get("cve", "Unknown")
        risk_score = finding.get("composite_risk_score", 0)
        exploit_available = finding.get("exploit_available", False)
        print(f"   {cve}: Risk score {risk_score:.1f}/10, Exploit available: {exploit_available}")
    
    # Show intelligence summary
    summary = enriched["intelligence_summary"]
    print(f"‚úÖ Intelligence summary: {summary['total_vulnerabilities']} vulnerabilities")
    print(f"   Severity breakdown: {summary['severity_breakdown']}")
    print(f"   Exploitable: {summary['exploitable_vulnerabilities']}")
    
    print()


async def demo_graph_database():
    """Demonstrate graph database functionality."""
    print("üï∏Ô∏è  Graph Database Demo")
    print("=" * 50)
    
    from aider.pentest.graph.database import GraphDatabase
    from aider.pentest.config import PentestConfig
    import tempfile
    
    config = PentestConfig()
    
    # Use temporary database
    with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as f:
        db_path = f.name
    
    try:
        graph_db = GraphDatabase(config, db_path)
        await graph_db.initialize()
        print("‚úÖ Graph database initialized")
        
        # Add targets
        target1_id = await graph_db.add_target("192.168.1.100")
        target2_id = await graph_db.add_target("10.0.0.50")
        print(f"‚úÖ Added targets: {target1_id}, {target2_id}")
        
        # Add ports
        port1_id = await graph_db.add_port(target1_id, 80, "http", "open")
        port2_id = await graph_db.add_port(target1_id, 22, "ssh", "open")
        port3_id = await graph_db.add_port(target2_id, 445, "smb", "open")
        print(f"‚úÖ Added ports: HTTP, SSH, SMB")
        
        # Add vulnerabilities
        vuln_data = {
            "cve": "CVE-2021-44228",
            "cvss_score": 10.0,
            "severity": "CRITICAL",
            "description": "Log4j RCE vulnerability"
        }
        vuln_id = await graph_db.add_vulnerability(target1_id, vuln_data)
        print(f"‚úÖ Added vulnerability: {vuln_data['cve']}")
        
        # Add credentials
        cred_id = await graph_db.add_credential("admin", "password123", "ssh", target1_id)
        print("‚úÖ Added credential: admin/password123 for SSH")
        
        # Get statistics
        stats = await graph_db.get_statistics()
        print(f"‚úÖ Database statistics: {stats['nodes']} nodes, {stats['relationships']} relationships")
        
        # Calculate risk
        risk_score = await graph_db.calculate_risk_propagation(vuln_id)
        print(f"‚úÖ Risk calculation: {risk_score:.1f}/10 for Log4j vulnerability")
        
        # Find lateral movement paths
        paths = await graph_db.find_lateral_movement_paths(target1_id, target2_id)
        print(f"‚úÖ Lateral movement analysis: {len(paths)} potential paths found")
        
        await graph_db.close()
        
    finally:
        Path(db_path).unlink(missing_ok=True)
    
    print()


async def demo_compliance():
    """Demonstrate compliance and security features."""
    print("üõ°Ô∏è  Compliance & Security Demo")
    print("=" * 50)
    
    from aider.pentest.compliance.guardian import ComplianceGuardian
    from aider.pentest.config import PentestConfig
    
    config = PentestConfig()
    guardian = ComplianceGuardian(config)
    
    # Security verification
    verified = await guardian.verify_setup()
    print(f"‚úÖ Security setup verification: {'PASSED' if verified else 'FAILED'}")
    
    # Consent verification
    test_targets = ["localhost", "192.168.1.100", "8.8.8.8"]
    for target in test_targets:
        consent = await guardian.verify_consent(target)
        allowed = await guardian.check_target_allowed(target)
        status = "‚úÖ ALLOWED" if (consent and allowed) else "‚ùå BLOCKED"
        print(f"   Target {target}: {status}")
    
    # Action validation
    actions = [
        ("port_scan", {"target": "localhost"}),
        ("destructive_exploit", {"target": "external.com"}),
        ("data_exfiltration", {"target": "192.168.1.100"})
    ]
    
    for action, context in actions:
        valid = await guardian.validate_action(action, context)
        status = "‚úÖ ALLOWED" if valid else "‚ùå BLOCKED"
        print(f"   Action {action}: {status}")
    
    # Compliance reporting
    soc2_report = await guardian.generate_compliance_report("SOC2")
    print(f"‚úÖ SOC 2 compliance report generated with {len(soc2_report['compliance_status'])} controls")
    
    iso_report = await guardian.generate_compliance_report("ISO27001")
    print(f"‚úÖ ISO 27001 compliance report generated with {len(iso_report['compliance_status'])} controls")
    
    # Audit log integrity
    integrity = await guardian._verify_audit_log_integrity()
    print(f"‚úÖ Audit log integrity: {integrity['integrity_percentage']:.1f}% ({integrity['valid_logs']}/{integrity['total_logs']} valid)")
    
    print()


async def demo_reporting():
    """Demonstrate reporting capabilities."""
    print("üìä Reporting API Demo")
    print("=" * 50)
    
    from aider.pentest.reporting.api import ReportGenerator
    
    generator = ReportGenerator()
    
    # Sample assessment results
    sample_results = {
        "id": "demo_assessment_001",
        "target": "demo.example.com",
        "type": "web",
        "start_time": "2024-01-15T10:00:00Z",
        "end_time": "2024-01-15T12:30:00Z",
        "status": "completed",
        "phases": [
            {
                "name": "reconnaissance",
                "agent": "recon",
                "status": "completed",
                "task_results": [
                    {
                        "findings": [
                            {
                                "cve": "CVE-2021-44228",
                                "severity": "CRITICAL",
                                "cvss_score": 10.0,
                                "composite_risk_score": 9.8,
                                "description": "Apache Log4j Remote Code Execution",
                                "exploit_available": True
                            },
                            {
                                "cve": "CVE-2019-0708",
                                "severity": "CRITICAL", 
                                "cvss_score": 9.8,
                                "composite_risk_score": 8.5,
                                "description": "BlueKeep RDP Remote Code Execution",
                                "exploit_available": True
                            }
                        ]
                    }
                ]
            }
        ]
    }
    
    # Generate reports in different formats
    formats = ["json", "html", "markdown"]
    
    for format_type in formats:
        if format_type == "json":
            report = await generator.generate_json_report(sample_results)
            print(f"‚úÖ JSON report generated: {len(report)} characters")
        elif format_type == "html":
            report = await generator.generate_html_report(sample_results)
            print(f"‚úÖ HTML report generated: {len(report)} characters")
        elif format_type == "markdown":
            report = await generator.generate_markdown_report(sample_results)
            print(f"‚úÖ Markdown report generated: {len(report)} characters")
    
    # PDF report (mock)
    pdf_content = await generator.generate_pdf_report(sample_results)
    print(f"‚úÖ PDF report generated: {len(pdf_content)} bytes (mock implementation)")
    
    print()


async def demo_tool_orchestration():
    """Demonstrate tool orchestration."""
    print("üîß Tool Orchestration Demo")
    print("=" * 50)
    
    from aider.pentest.tools.orchestrator import ToolOrchestrator, SecurityTool
    from aider.pentest.config import PentestConfig
    
    config = PentestConfig()
    orchestrator = ToolOrchestrator(config)
    
    # Show available tools
    tools = await orchestrator.get_available_tools()
    print("‚úÖ Available security tools:")
    
    for tool_name, tool_info in tools.items():
        status = "‚úÖ Installed" if tool_info["installed"] else "‚ùå Not installed"
        version = f" (v{tool_info['version']})" if tool_info.get("version") else ""
        print(f"   {tool_name}: {status}{version}")
    
    # Tool failure rate
    failure_rate = await orchestrator.get_tool_failure_rate()
    print(f"‚úÖ Tool failure rate: {failure_rate*100:.1f}% (target: ‚â§10%)")
    
    # Custom tool registration demo
    custom_tool = {
        "name": "demo_scanner",
        "install_cmd": "echo 'Installing demo scanner'",
        "check_cmd": "echo 'Demo Scanner v1.0'",
        "sandbox": True
    }
    
    success = await orchestrator.register_custom_tool(custom_tool)
    print(f"‚úÖ Custom tool registration: {'SUCCESS' if success else 'FAILED'}")
    
    print()


async def demo_agent_coordination():
    """Demonstrate multi-agent coordination."""
    print("ü§ñ Multi-Agent Coordination Demo")
    print("=" * 50)
    
    from aider.pentest.agents.coordinator import AgentCoordinator
    from aider.pentest.config import PentestConfig
    
    # Mock IO for testing
    class MockIO:
        def __init__(self):
            pass
        
        def tool_output(self, message, log_only=False):
            if not log_only:
                print(f"    {message}")
    
    config = PentestConfig()
    io = MockIO()
    coordinator = AgentCoordinator(config, io)
    
    print("‚úÖ Agent coordinator initialized with agents:")
    for agent_type, agent in coordinator.agents.items():
        print(f"   {agent_type}: {agent.__class__.__name__}")
    
    # Create mock workflow
    mock_workflow = {
        "name": "demo_workflow",
        "phases": [
            {
                "name": "reconnaissance",
                "agent": "recon",
                "tasks": [
                    {"type": "port_scan", "target": "demo.com"},
                    {"type": "service_enum", "target": "demo.com"}
                ]
            },
            {
                "name": "exploitation",
                "agent": "exploit", 
                "tasks": [
                    {"type": "vulnerability_test", "target": "demo.com"}
                ]
            },
            {
                "name": "reporting",
                "agent": "reporting",
                "tasks": [
                    {"type": "generate_report", "format": "html"}
                ]
            }
        ]
    }
    
    # Execute workflow
    print("‚úÖ Executing demo workflow...")
    results = await coordinator.execute_workflow(mock_workflow, "demo.com")
    
    print(f"‚úÖ Workflow execution completed:")
    print(f"   Status: {results.get('status')}")
    print(f"   Phases executed: {len(results.get('phases', []))}")
    
    # Agent status
    status = await coordinator.get_agent_status()
    print("‚úÖ Agent status:")
    for agent_type, agent_status in status.items():
        print(f"   {agent_type}: {agent_status['status']}")
    
    print()


async def main():
    """Run the complete demo."""
    print("üîí Aider Pentesting Agent - Comprehensive Demo")
    print("=" * 60)
    print("This demo showcases all key features of the pentesting framework")
    print("=" * 60)
    print()
    
    try:
        await demo_configuration()
        await demo_workflows()
        await demo_vulnerability_intel() 
        await demo_graph_database()
        await demo_compliance()
        await demo_reporting()
        await demo_tool_orchestration()
        await demo_agent_coordination()
        
        print("üéâ Demo Completed Successfully!")
        print("=" * 60)
        print("All core pentesting agent features are working correctly.")
        print()
        print("Next steps:")
        print("1. Install dependencies: pip install aider-chat[pentest]")
        print("2. Run demo campaign: aider --pentest-demo")
        print("3. Start assessment: aider --pentest --pentest-target <target>")
        print("4. Use Docker setup: ./setup_demo.sh")
        print()
        print("üìö Documentation: See PENTEST_README.md for complete usage guide")
        
    except Exception as e:
        print(f"‚ùå Demo failed: {e}")
        import traceback
        traceback.print_exc()
        return 1
    
    return 0


if __name__ == "__main__":
    exit_code = asyncio.run(main())
    sys.exit(exit_code)