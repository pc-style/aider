"""Tests for the pentesting agent framework."""

import pytest
import asyncio
import tempfile
from pathlib import Path

from aider.pentest import PentestAgent, PentestConfig
from aider.pentest.config import LLMProviderConfig, SecurityConfig, ToolConfig, AgentConfig
from aider.io import InputOutput


class TestPentestConfig:
    """Test pentesting configuration."""
    
    def test_default_config(self):
        """Test default configuration creation."""
        config = PentestConfig()
        
        assert len(config.llm_providers) > 0
        assert config.security_config.enforce_zero_trust is True
        assert config.tool_config.auto_install is True
        assert "json" in config.report_formats
    
    def test_config_serialization(self):
        """Test configuration serialization/deserialization."""
        config = PentestConfig()
        
        # Test to_dict
        config_dict = config.to_dict()
        assert isinstance(config_dict, dict)
        assert "llm_providers" in config_dict
        assert "security_config" in config_dict
        
        # Test from_dict
        new_config = PentestConfig.from_dict(config_dict)
        assert len(new_config.llm_providers) == len(config.llm_providers)
        assert new_config.security_config.enforce_zero_trust == config.security_config.enforce_zero_trust
    
    def test_config_file_operations(self):
        """Test saving and loading configuration files."""
        config = PentestConfig()
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            config_path = f.name
        
        try:
            # Save config
            config.save_to_file(config_path)
            assert Path(config_path).exists()
            
            # Load config
            loaded_config = PentestConfig.from_file(config_path)
            assert len(loaded_config.llm_providers) == len(config.llm_providers)
            
        finally:
            Path(config_path).unlink(missing_ok=True)
    
    def test_enabled_providers(self):
        """Test getting enabled providers."""
        config = PentestConfig()
        
        # Disable one provider
        config.llm_providers[0].enabled = False
        
        enabled = config.get_enabled_providers()
        assert len(enabled) == len(config.llm_providers) - 1
        assert all(provider.enabled for provider in enabled)


class TestPentestAgent:
    """Test the main pentesting agent."""
    
    @pytest.fixture
    def config(self):
        """Create test configuration."""
        config = PentestConfig()
        config.security_config.audit_log_enabled = False  # Disable for tests
        config.tool_config.auto_install = False  # Disable for tests
        config.report_api_enabled = False  # Disable for tests
        return config
    
    @pytest.fixture
    def io(self):
        """Create test IO."""
        return InputOutput(pretty=False, yes=True)
    
    @pytest.fixture
    def agent(self, config, io):
        """Create test agent."""
        return PentestAgent(config, io)
    
    @pytest.mark.asyncio
    async def test_agent_initialization(self, agent):
        """Test agent initialization."""
        await agent.initialize()
        
        # Check that components are initialized
        assert agent.coordinator is not None
        assert agent.tool_orchestrator is not None
        assert agent.workflow_manager is not None
        assert agent.graph_db is not None
        assert agent.vuln_intel is not None
        assert agent.compliance_guardian is not None
        assert agent.reporting_api is not None
    
    @pytest.mark.asyncio
    async def test_agent_status(self, agent):
        """Test getting agent status."""
        await agent.initialize()
        
        status = await agent.get_status()
        
        assert "agent_status" in status
        assert "enabled_providers" in status
        assert "available_tools" in status
        assert "workflow_templates" in status
        assert "compliance_status" in status
    
    @pytest.mark.asyncio 
    async def test_agent_shutdown(self, agent):
        """Test agent shutdown."""
        await agent.initialize()
        await agent.shutdown()
        
        # Should not raise any exceptions


class TestWorkflowManager:
    """Test workflow management."""
    
    @pytest.fixture
    def config(self):
        return PentestConfig()
    
    @pytest.fixture
    def workflow_manager(self, config):
        from aider.pentest.workflows.manager import WorkflowManager
        return WorkflowManager(config)
    
    @pytest.mark.asyncio
    async def test_list_templates(self, workflow_manager):
        """Test listing workflow templates."""
        templates = await workflow_manager.list_templates()
        
        assert "builtin" in templates
        assert "demo" in templates
        assert "custom" in templates
        
        # Check that built-in templates are available
        assert "web" in templates["builtin"]
        assert "network" in templates["builtin"]
        assert "juice_shop" in templates["demo"]
    
    @pytest.mark.asyncio
    async def test_create_workflow(self, workflow_manager):
        """Test creating workflows."""
        # Test web workflow
        web_workflow = await workflow_manager.create_workflow("web")
        assert web_workflow["name"] == "web_application"
        assert web_workflow["domain"] == "web"
        assert len(web_workflow["phases"]) > 0
        
        # Test full workflow
        full_workflow = await workflow_manager.create_workflow("full")
        assert full_workflow["name"] == "comprehensive_assessment"
        assert len(full_workflow["phases"]) > 0
    
    @pytest.mark.asyncio
    async def test_load_template(self, workflow_manager):
        """Test loading specific templates."""
        # Load demo template
        juice_shop = await workflow_manager.load_template("juice_shop")
        assert juice_shop["name"] == "juice_shop_assessment"
        assert juice_shop["domain"] == "web"
    
    @pytest.mark.asyncio
    async def test_validate_template(self, workflow_manager):
        """Test template validation."""
        valid_template = {
            "name": "test_template",
            "description": "Test template",
            "domain": "test",
            "phases": [
                {
                    "name": "test_phase",
                    "agent": "recon",
                    "tasks": [{"type": "test_task"}]
                }
            ]
        }
        
        errors = await workflow_manager.validate_template(valid_template)
        assert len(errors) == 0
        
        # Test invalid template
        invalid_template = {
            "name": "invalid",
            "phases": []  # Missing required fields
        }
        
        errors = await workflow_manager.validate_template(invalid_template)
        assert len(errors) > 0


class TestGraphDatabase:
    """Test graph database functionality."""
    
    @pytest.fixture
    def config(self):
        return PentestConfig()
    
    @pytest.fixture
    def graph_db(self, config):
        from aider.pentest.graph.database import GraphDatabase
        
        with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as f:
            db_path = f.name
        
        db = GraphDatabase(config, db_path)
        yield db
        
        # Cleanup
        Path(db_path).unlink(missing_ok=True)
    
    @pytest.mark.asyncio
    async def test_graph_initialization(self, graph_db):
        """Test graph database initialization."""
        await graph_db.initialize()
        assert graph_db.connection is not None
    
    @pytest.mark.asyncio
    async def test_add_target(self, graph_db):
        """Test adding targets to the graph."""
        await graph_db.initialize()
        
        target_id = await graph_db.add_target("192.168.1.100")
        assert target_id.startswith("host_")
        
        hosts = await graph_db.get_nodes_by_type("host")
        assert len(hosts) == 1
        assert hosts[0]["properties"]["ip_address"] == "192.168.1.100"
    
    @pytest.mark.asyncio
    async def test_add_port(self, graph_db):
        """Test adding ports to hosts."""
        await graph_db.initialize()
        
        target_id = await graph_db.add_target("192.168.1.100") 
        port_id = await graph_db.add_port(target_id, 80, "http", "open")
        
        ports = await graph_db.get_nodes_by_type("port")
        assert len(ports) == 1
        assert ports[0]["properties"]["port_number"] == 80
        
        # Check relationship
        relationships = await graph_db.get_node_relationships(target_id)
        assert len(relationships) == 1
        assert relationships[0]["relationship"] == "has_port"
    
    @pytest.mark.asyncio
    async def test_add_vulnerability(self, graph_db):
        """Test adding vulnerabilities."""
        await graph_db.initialize()
        
        target_id = await graph_db.add_target("192.168.1.100")
        
        vuln_data = {
            "cve": "CVE-2021-44228",
            "cvss_score": 10.0,
            "severity": "CRITICAL",
            "description": "Log4j RCE"
        }
        
        vuln_id = await graph_db.add_vulnerability(target_id, vuln_data)
        
        vulns = await graph_db.get_nodes_by_type("vulnerability")
        assert len(vulns) == 1
        assert vulns[0]["properties"]["cve"] == "CVE-2021-44228"
    
    @pytest.mark.asyncio
    async def test_risk_calculation(self, graph_db):
        """Test risk score calculation."""
        await graph_db.initialize()
        
        target_id = await graph_db.add_target("192.168.1.100")
        
        vuln_data = {
            "cve": "CVE-2021-44228",
            "cvss_score": 10.0,
            "exploitability_score": 9.8
        }
        
        vuln_id = await graph_db.add_vulnerability(target_id, vuln_data)
        
        risk_score = await graph_db.calculate_risk_propagation(vuln_id)
        assert risk_score > 0
        assert risk_score <= 10.0


class TestVulnerabilityIntel:
    """Test vulnerability intelligence module."""
    
    @pytest.fixture
    def config(self):
        return PentestConfig()
    
    @pytest.fixture
    def vuln_intel(self, config):
        from aider.pentest.intel.vulnerability import VulnerabilityIntel
        return VulnerabilityIntel(config)
    
    @pytest.mark.asyncio
    async def test_intel_initialization(self, vuln_intel):
        """Test vulnerability intelligence initialization."""
        await vuln_intel.initialize()
        
        # Should have some mock CVE data
        assert len(vuln_intel.cve_cache) > 0
        assert len(vuln_intel.exploit_db) > 0
    
    @pytest.mark.asyncio
    async def test_enrich_findings(self, vuln_intel):
        """Test enriching findings with intelligence."""
        await vuln_intel.initialize()
        
        findings = {
            "target": "test.example.com",
            "phases": [
                {
                    "name": "test_phase",
                    "task_results": [
                        {
                            "findings": [
                                {
                                    "cve": "CVE-2021-44228",
                                    "service": "java"
                                }
                            ]
                        }
                    ]
                }
            ]
        }
        
        enriched = await vuln_intel.enrich_findings(findings)
        
        # Check that intelligence was added
        finding = enriched["phases"][0]["task_results"][0]["findings"][0]
        assert "cvss_score" in finding
        assert "severity" in finding
        assert "composite_risk_score" in finding
        
        # Check intelligence summary
        assert "intelligence_summary" in enriched
        summary = enriched["intelligence_summary"]
        assert "total_vulnerabilities" in summary
        assert "severity_breakdown" in summary


if __name__ == "__main__":
    pytest.main([__file__])