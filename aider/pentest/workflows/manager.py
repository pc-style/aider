"""
Workflow manager for domain-specific pentesting templates.
Supports web, network, social-engineering, reverse-engineering, fuzzing, and post-exploitation workflows.
"""

import json
import os
from typing import Dict, List, Any, Optional
from pathlib import Path
import logging

from ..config import PentestConfig


class WorkflowManager:
    """Manages pentesting workflow templates for different domains."""
    
    def __init__(self, config: PentestConfig):
        self.config = config
        self.logger = logging.getLogger("workflow.manager")
        self.templates_dir = Path(__file__).parent / "templates"
        self.custom_templates_dir = Path("./custom_workflows")
        
        # Ensure directories exist
        self.templates_dir.mkdir(exist_ok=True)
        self.custom_templates_dir.mkdir(exist_ok=True)
        
        # Initialize built-in templates
        self._initialize_builtin_templates()
    
    def _initialize_builtin_templates(self):
        """Initialize built-in workflow templates."""
        
        # Web Application Testing Workflow
        web_workflow = {
            "name": "web_application",
            "description": "Comprehensive web application security assessment",
            "domain": "web",
            "phases": [
                {
                    "name": "reconnaissance",
                    "agent": "recon",
                    "tasks": [
                        {"type": "port_scan", "ports": [80, 443, 8080, 8443]},
                        {"type": "service_enum", "services": ["http", "https"]},
                        {"type": "subdomain_enum", "tools": ["gobuster", "dirb"]}
                    ]
                },
                {
                    "name": "vulnerability_scanning",
                    "agent": "recon", 
                    "tasks": [
                        {"type": "web_scan", "tools": ["nikto", "sqlmap"]},
                        {"type": "directory_bruteforce", "tools": ["gobuster"]},
                        {"type": "parameter_fuzzing"}
                    ]
                },
                {
                    "name": "exploitation", 
                    "agent": "exploit",
                    "tasks": [
                        {"type": "sql_injection", "tools": ["sqlmap"]},
                        {"type": "xss_testing"},
                        {"type": "authentication_bypass"}
                    ]
                },
                {
                    "name": "reporting",
                    "agent": "reporting",
                    "tasks": [
                        {"type": "generate_report", "format": "html"},
                        {"type": "evidence_collection"}
                    ]
                }
            ]
        }
        
        # Network Penetration Testing Workflow
        network_workflow = {
            "name": "network_penetration",
            "description": "Network infrastructure security assessment",
            "domain": "network",
            "phases": [
                {
                    "name": "discovery",
                    "agent": "recon",
                    "tasks": [
                        {"type": "host_discovery", "tools": ["nmap", "masscan"]},
                        {"type": "port_scan", "scan_type": "full"},
                        {"type": "os_fingerprinting"}
                    ]
                },
                {
                    "name": "service_enumeration",
                    "agent": "recon",
                    "tasks": [
                        {"type": "service_scan", "tools": ["nmap"]},
                        {"type": "banner_grabbing"},
                        {"type": "smb_enumeration"},
                        {"type": "snmp_enumeration"}
                    ]
                },
                {
                    "name": "vulnerability_assessment",
                    "agent": "exploit",
                    "tasks": [
                        {"type": "vuln_scan", "tools": ["nmap"]},
                        {"type": "credential_testing"},
                        {"type": "service_exploitation"}
                    ]
                },
                {
                    "name": "lateral_movement",
                    "agent": "exploit", 
                    "tasks": [
                        {"type": "privilege_escalation"},
                        {"type": "credential_harvesting"},
                        {"type": "network_pivoting"}
                    ]
                }
            ]
        }
        
        # Social Engineering Workflow
        social_engineering_workflow = {
            "name": "social_engineering",
            "description": "Social engineering and phishing assessment",
            "domain": "social_engineering",
            "phases": [
                {
                    "name": "reconnaissance",
                    "agent": "recon",
                    "tasks": [
                        {"type": "osint_gathering"},
                        {"type": "employee_enumeration"},
                        {"type": "email_harvesting"}
                    ]
                },
                {
                    "name": "phishing_campaign",
                    "agent": "exploit",
                    "tasks": [
                        {"type": "email_templates"},
                        {"type": "landing_pages"},
                        {"type": "payload_delivery"}
                    ]
                },
                {
                    "name": "social_media",
                    "agent": "exploit",
                    "tasks": [
                        {"type": "profile_analysis"},
                        {"type": "connection_mapping"},
                        {"type": "social_attacks"}
                    ]
                }
            ]
        }
        
        # Reverse Engineering Workflow
        reverse_engineering_workflow = {
            "name": "reverse_engineering",
            "description": "Binary and malware reverse engineering",
            "domain": "reverse_engineering",
            "phases": [
                {
                    "name": "static_analysis",
                    "agent": "recon",
                    "tasks": [
                        {"type": "file_analysis"},
                        {"type": "string_extraction"},
                        {"type": "disassembly"}
                    ]
                },
                {
                    "name": "dynamic_analysis",
                    "agent": "exploit",
                    "tasks": [
                        {"type": "sandbox_execution"},
                        {"type": "api_monitoring"},
                        {"type": "network_behavior"}
                    ]
                },
                {
                    "name": "vulnerability_research",
                    "agent": "exploit",
                    "tasks": [
                        {"type": "fuzzing"},
                        {"type": "exploit_development"},
                        {"type": "proof_of_concept"}
                    ]
                }
            ]
        }
        
        # Fuzzing Workflow
        fuzzing_workflow = {
            "name": "fuzzing",
            "description": "Application and protocol fuzzing",
            "domain": "fuzzing",
            "phases": [
                {
                    "name": "target_preparation",
                    "agent": "recon",
                    "tasks": [
                        {"type": "input_identification"},
                        {"type": "protocol_analysis"},
                        {"type": "test_case_generation"}
                    ]
                },
                {
                    "name": "fuzzing_execution",
                    "agent": "exploit",
                    "tasks": [
                        {"type": "web_fuzzing"},
                        {"type": "api_fuzzing"},
                        {"type": "binary_fuzzing"}
                    ]
                },
                {
                    "name": "crash_analysis",
                    "agent": "exploit",
                    "tasks": [
                        {"type": "crash_triage"},
                        {"type": "exploitability_assessment"},
                        {"type": "poc_development"}
                    ]
                }
            ]
        }
        
        # Post-Exploitation Workflow
        post_exploitation_workflow = {
            "name": "post_exploitation",
            "description": "Post-exploitation and persistence",
            "domain": "post_exploitation",
            "phases": [
                {
                    "name": "persistence",
                    "agent": "exploit",
                    "tasks": [
                        {"type": "backdoor_installation"},
                        {"type": "service_creation"},
                        {"type": "scheduled_tasks"}
                    ]
                },
                {
                    "name": "privilege_escalation",
                    "agent": "exploit",
                    "tasks": [
                        {"type": "local_enumeration"},
                        {"type": "exploit_suggestion"},
                        {"type": "privilege_abuse"}
                    ]
                },
                {
                    "name": "data_exfiltration",
                    "agent": "exploit",
                    "tasks": [
                        {"type": "data_discovery"},
                        {"type": "compression"},
                        {"type": "covert_channels"}
                    ]
                },
                {
                    "name": "cleanup",
                    "agent": "cleanup",
                    "tasks": [
                        {"type": "artifact_removal"},
                        {"type": "log_clearing"},
                        {"type": "backdoor_removal"}
                    ]
                }
            ]
        }
        
        # Save built-in templates
        self.builtin_templates = {
            "web": web_workflow,
            "network": network_workflow,
            "social_engineering": social_engineering_workflow,
            "reverse_engineering": reverse_engineering_workflow,
            "fuzzing": fuzzing_workflow,
            "post_exploitation": post_exploitation_workflow
        }
        
        # Demo-specific templates
        self.demo_templates = {
            "juice_shop": {
                "name": "juice_shop_assessment",
                "description": "OWASP Juice Shop automated assessment",
                "domain": "web",
                "phases": [
                    {
                        "name": "juice_shop_recon",
                        "agent": "recon",
                        "tasks": [
                            {"type": "port_scan", "ports": [3000]},
                            {"type": "directory_scan"},
                            {"type": "api_enumeration"}
                        ]
                    },
                    {
                        "name": "juice_shop_exploit",
                        "agent": "exploit",
                        "tasks": [
                            {"type": "sql_injection"},
                            {"type": "xss_attacks"},
                            {"type": "broken_auth"},
                            {"type": "security_misconfig"}
                        ]
                    }
                ]
            },
            "metasploitable": {
                "name": "metasploitable_assessment",
                "description": "Metasploitable 2 automated exploitation",
                "domain": "network",
                "phases": [
                    {
                        "name": "metasploitable_recon",
                        "agent": "recon",
                        "tasks": [
                            {"type": "port_scan", "scan_type": "comprehensive"},
                            {"type": "service_enumeration"},
                            {"type": "vulnerability_identification"}
                        ]
                    },
                    {
                        "name": "metasploitable_exploit",
                        "agent": "exploit",
                        "tasks": [
                            {"type": "vsftpd_backdoor"},
                            {"type": "distcc_exploit"},
                            {"type": "samba_exploit"},
                            {"type": "ssh_bruteforce"}
                        ]
                    }
                ]
            },
            "phishing_sim": {
                "name": "phishing_simulation",
                "description": "Comprehensive phishing simulation",
                "domain": "social_engineering",
                "phases": [
                    {
                        "name": "target_research",
                        "agent": "recon",
                        "tasks": [
                            {"type": "employee_enumeration"},
                            {"type": "social_media_intel"},
                            {"type": "email_template_creation"}
                        ]
                    },
                    {
                        "name": "campaign_execution",
                        "agent": "exploit",
                        "tasks": [
                            {"type": "phishing_emails"},
                            {"type": "credential_harvesting"},
                            {"type": "payload_delivery"}
                        ]
                    }
                ]
            }
        }
        
        # Save templates to files
        self._save_builtin_templates()
    
    def _save_builtin_templates(self):
        """Save built-in templates to files."""
        for name, template in self.builtin_templates.items():
            template_file = self.templates_dir / f"{name}.json"
            with open(template_file, 'w') as f:
                json.dump(template, f, indent=2)
        
        for name, template in self.demo_templates.items():
            template_file = self.templates_dir / f"{name}.json"
            with open(template_file, 'w') as f:
                json.dump(template, f, indent=2)
    
    async def create_workflow(self, assessment_type: str) -> Dict[str, Any]:
        """Create a workflow based on assessment type."""
        if assessment_type == "full":
            # Combine multiple domain workflows
            return await self._create_comprehensive_workflow()
        elif assessment_type in self.builtin_templates:
            return self.builtin_templates[assessment_type]
        else:
            # Default to web assessment
            self.logger.warning(f"Unknown assessment type: {assessment_type}, defaulting to web")
            return self.builtin_templates["web"]
    
    async def _create_comprehensive_workflow(self) -> Dict[str, Any]:
        """Create a comprehensive workflow combining multiple domains."""
        comprehensive_workflow = {
            "name": "comprehensive_assessment",
            "description": "Full multi-domain security assessment",
            "domain": "comprehensive",
            "phases": []
        }
        
        # Add phases from different domain workflows
        for domain in ["network", "web", "social_engineering"]:
            template = self.builtin_templates[domain]
            for phase in template["phases"]:
                phase_copy = phase.copy()
                phase_copy["name"] = f"{domain}_{phase['name']}"
                comprehensive_workflow["phases"].append(phase_copy)
        
        return comprehensive_workflow
    
    async def load_template(self, template_name: str) -> Dict[str, Any]:
        """Load a specific workflow template."""
        # Check demo templates first
        if template_name in self.demo_templates:
            return self.demo_templates[template_name]
        
        # Check built-in templates
        if template_name in self.builtin_templates:
            return self.builtin_templates[template_name]
        
        # Try to load from file
        template_file = self.templates_dir / f"{template_name}.json"
        if template_file.exists():
            with open(template_file, 'r') as f:
                return json.load(f)
        
        # Try custom templates directory
        custom_template_file = self.custom_templates_dir / f"{template_name}.json"
        if custom_template_file.exists():
            with open(custom_template_file, 'r') as f:
                return json.load(f)
        
        raise ValueError(f"Template not found: {template_name}")
    
    async def save_custom_template(self, template: Dict[str, Any]) -> bool:
        """Save a custom workflow template."""
        template_name = template.get("name")
        if not template_name:
            raise ValueError("Template must have a name")
        
        template_file = self.custom_templates_dir / f"{template_name}.json"
        
        try:
            with open(template_file, 'w') as f:
                json.dump(template, f, indent=2)
            
            self.logger.info(f"Saved custom template: {template_name}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to save template {template_name}: {e}")
            return False
    
    async def list_templates(self) -> Dict[str, List[str]]:
        """List available workflow templates by category."""
        templates = {
            "builtin": list(self.builtin_templates.keys()),
            "demo": list(self.demo_templates.keys()),
            "custom": []
        }
        
        # Scan for custom templates
        try:
            for template_file in self.custom_templates_dir.glob("*.json"):
                templates["custom"].append(template_file.stem)
        except Exception as e:
            self.logger.error(f"Error scanning custom templates: {e}")
        
        return templates
    
    async def validate_template(self, template: Dict[str, Any]) -> List[str]:
        """Validate a workflow template and return any errors."""
        errors = []
        
        # Check required fields
        required_fields = ["name", "description", "domain", "phases"]
        for field in required_fields:
            if field not in template:
                errors.append(f"Missing required field: {field}")
        
        # Validate phases
        if "phases" in template:
            for i, phase in enumerate(template["phases"]):
                phase_errors = self._validate_phase(phase, i)
                errors.extend(phase_errors)
        
        return errors
    
    def _validate_phase(self, phase: Dict[str, Any], phase_index: int) -> List[str]:
        """Validate a single phase of a workflow."""
        errors = []
        
        # Check required phase fields
        required_fields = ["name", "agent", "tasks"]
        for field in required_fields:
            if field not in phase:
                errors.append(f"Phase {phase_index}: Missing required field: {field}")
        
        # Validate agent type
        valid_agents = ["recon", "exploit", "reporting", "cleanup"]
        if "agent" in phase and phase["agent"] not in valid_agents:
            errors.append(f"Phase {phase_index}: Invalid agent type: {phase['agent']}")
        
        # Validate tasks
        if "tasks" in phase:
            if not isinstance(phase["tasks"], list):
                errors.append(f"Phase {phase_index}: Tasks must be a list")
            elif len(phase["tasks"]) == 0:
                errors.append(f"Phase {phase_index}: Must have at least one task")
        
        return errors