"""
Reporting API for generating PDF, HTML, Markdown and JSON reports.
Exposes REST endpoint for CI pipeline integration.
"""

import asyncio
import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional
import base64

try:
    from aiohttp import web, ClientSession
except ImportError:
    web = None
    ClientSession = None

from ..config import PentestConfig


class ReportGenerator:
    """Generates reports in various formats from assessment results."""
    
    def __init__(self):
        self.logger = logging.getLogger("reporting.generator")
    
    async def generate_json_report(self, results: Dict[str, Any]) -> str:
        """Generate JSON format report."""
        report = {
            "report_metadata": {
                "format": "json",
                "generated_at": datetime.now().isoformat(),
                "generator": "Aider Pentesting Agent",
                "version": "1.0.0"
            },
            "assessment_summary": self._create_summary(results),
            "detailed_findings": results,
            "recommendations": self._generate_recommendations(results)
        }
        
        return json.dumps(report, indent=2)
    
    async def generate_html_report(self, results: Dict[str, Any]) -> str:
        """Generate HTML format report."""
        summary = self._create_summary(results)
        
        html_template = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Penetration Test Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        .header {{ background-color: #f4f4f4; padding: 20px; margin-bottom: 20px; }}
        .summary {{ background-color: #e8f4f8; padding: 15px; margin-bottom: 20px; }}
        .critical {{ color: #d32f2f; font-weight: bold; }}
        .high {{ color: #f57c00; font-weight: bold; }}
        .medium {{ color: #fbc02d; font-weight: bold; }}
        .low {{ color: #388e3c; font-weight: bold; }}
        .finding {{ border: 1px solid #ddd; padding: 15px; margin-bottom: 10px; }}
        .metadata {{ font-size: 0.9em; color: #666; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>Penetration Test Report</h1>
        <p class="metadata">Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        <p class="metadata">Target: {results.get('target', 'Unknown')}</p>
    </div>
    
    <div class="summary">
        <h2>Executive Summary</h2>
        <p><strong>Total Findings:</strong> {summary['total_findings']}</p>
        <p><strong>Critical:</strong> <span class="critical">{summary['critical']}</span></p>
        <p><strong>High:</strong> <span class="high">{summary['high']}</span></p>
        <p><strong>Medium:</strong> <span class="medium">{summary['medium']}</span></p>
        <p><strong>Low:</strong> <span class="low">{summary['low']}</span></p>
        <p><strong>Risk Score:</strong> {summary['risk_score']:.1f}/10</p>
    </div>
    
    <div class="findings">
        <h2>Detailed Findings</h2>
        {self._generate_html_findings(results)}
    </div>
    
    <div class="recommendations">
        <h2>Recommendations</h2>
        {self._generate_html_recommendations(results)}
    </div>
</body>
</html>
"""
        
        return html_template
    
    async def generate_markdown_report(self, results: Dict[str, Any]) -> str:
        """Generate Markdown format report."""
        summary = self._create_summary(results)
        
        markdown = f"""# Penetration Test Report

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}  
**Target:** {results.get('target', 'Unknown')}  
**Assessment Type:** {results.get('type', 'Unknown')}

## Executive Summary

| Metric | Value |
|--------|-------|
| Total Findings | {summary['total_findings']} |
| Critical | {summary['critical']} |
| High | {summary['high']} |
| Medium | {summary['medium']} |
| Low | {summary['low']} |
| Risk Score | {summary['risk_score']:.1f}/10 |

## Detailed Findings

{self._generate_markdown_findings(results)}

## Recommendations

{self._generate_markdown_recommendations(results)}

## Technical Details

{self._generate_markdown_technical_details(results)}
"""
        
        return markdown
    
    async def generate_pdf_report(self, results: Dict[str, Any]) -> bytes:
        """Generate PDF format report (mock implementation)."""
        # In a real implementation, would use libraries like ReportLab or WeasyPrint
        # For demo purposes, return encoded HTML as "PDF"
        
        html_content = await self.generate_html_report(results)
        
        # Mock PDF generation by encoding HTML
        pdf_content = f"""PDF Report (Mock Implementation)
Generated: {datetime.now().isoformat()}
Target: {results.get('target', 'Unknown')}

This would be a proper PDF in a production implementation.
For demo purposes, this is a text representation.

Summary:
{self._create_summary(results)}

Raw HTML Content:
{html_content}
"""
        
        return pdf_content.encode('utf-8')
    
    def _create_summary(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Create assessment summary."""
        summary = {
            "total_findings": 0,
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "risk_score": 0.0
        }
        
        all_findings = []
        for phase in results.get('phases', []):
            for task_result in phase.get('task_results', []):
                all_findings.extend(task_result.get('findings', []))
        
        summary["total_findings"] = len(all_findings)
        
        risk_scores = []
        for finding in all_findings:
            severity = finding.get('severity', '').upper()
            if severity in summary:
                summary[severity.lower()] += 1
            
            # Collect risk scores
            if 'composite_risk_score' in finding:
                risk_scores.append(finding['composite_risk_score'])
            elif 'cvss_score' in finding:
                risk_scores.append(finding['cvss_score'])
        
        # Calculate overall risk score
        if risk_scores:
            summary["risk_score"] = max(risk_scores)
        
        return summary
    
    def _generate_html_findings(self, results: Dict[str, Any]) -> str:
        """Generate HTML findings section."""
        findings_html = ""
        
        for phase in results.get('phases', []):
            findings_html += f"<h3>{phase.get('name', 'Unknown Phase')}</h3>"
            
            for task_result in phase.get('task_results', []):
                for finding in task_result.get('findings', []):
                    severity = finding.get('severity', 'unknown').lower()
                    cve = finding.get('cve', 'N/A')
                    description = finding.get('description', 'No description available')
                    risk_score = finding.get('composite_risk_score', finding.get('cvss_score', 0))
                    
                    findings_html += f"""
                    <div class="finding">
                        <h4 class="{severity}">CVE: {cve} ({severity.upper()})</h4>
                        <p><strong>Risk Score:</strong> {risk_score}</p>
                        <p><strong>Description:</strong> {description}</p>
                    </div>
                    """
        
        return findings_html
    
    def _generate_html_recommendations(self, results: Dict[str, Any]) -> str:
        """Generate HTML recommendations section."""
        recommendations = self._generate_recommendations(results)
        
        rec_html = "<ul>"
        for rec in recommendations:
            rec_html += f"<li>{rec}</li>"
        rec_html += "</ul>"
        
        return rec_html
    
    def _generate_markdown_findings(self, results: Dict[str, Any]) -> str:
        """Generate Markdown findings section."""
        findings_md = ""
        
        for phase in results.get('phases', []):
            findings_md += f"### {phase.get('name', 'Unknown Phase')}\n\n"
            
            for task_result in phase.get('task_results', []):
                for finding in task_result.get('findings', []):
                    severity = finding.get('severity', 'unknown').upper()
                    cve = finding.get('cve', 'N/A')
                    description = finding.get('description', 'No description available')
                    risk_score = finding.get('composite_risk_score', finding.get('cvss_score', 0))
                    
                    findings_md += f"""#### {cve} ({severity})

**Risk Score:** {risk_score}  
**Description:** {description}

"""
        
        return findings_md
    
    def _generate_markdown_recommendations(self, results: Dict[str, Any]) -> str:
        """Generate Markdown recommendations section."""
        recommendations = self._generate_recommendations(results)
        
        rec_md = ""
        for i, rec in enumerate(recommendations, 1):
            rec_md += f"{i}. {rec}\n"
        
        return rec_md
    
    def _generate_markdown_technical_details(self, results: Dict[str, Any]) -> str:
        """Generate technical details section in Markdown."""
        tech_md = f"""### Assessment Metadata

- **Assessment ID:** {results.get('id', 'Unknown')}
- **Start Time:** {results.get('start_time', 'Unknown')}
- **End Time:** {results.get('end_time', 'Unknown')}
- **Status:** {results.get('status', 'Unknown')}

### Phases Executed

"""
        
        for phase in results.get('phases', []):
            tech_md += f"- **{phase.get('name')}:** {phase.get('status', 'Unknown')} "
            tech_md += f"({len(phase.get('task_results', []))} tasks)\n"
        
        return tech_md
    
    def _generate_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate security recommendations."""
        recommendations = []
        
        # Analyze findings to generate recommendations
        critical_count = 0
        high_count = 0
        
        for phase in results.get('phases', []):
            for task_result in phase.get('task_results', []):
                for finding in task_result.get('findings', []):
                    severity = finding.get('severity', '').upper()
                    if severity == 'CRITICAL':
                        critical_count += 1
                    elif severity == 'HIGH':
                        high_count += 1
        
        if critical_count > 0:
            recommendations.append(f"Immediately address {critical_count} critical vulnerabilities")
        
        if high_count > 0:
            recommendations.append(f"Prioritize patching of {high_count} high-severity vulnerabilities")
        
        recommendations.extend([
            "Implement a vulnerability management program",
            "Conduct regular security assessments",
            "Establish security monitoring and alerting",
            "Provide security awareness training to staff",
            "Review and update security policies"
        ])
        
        return recommendations


class ReportingAPI:
    """REST API for report generation and access."""
    
    def __init__(self, config: PentestConfig):
        self.config = config
        self.logger = logging.getLogger("reporting.api")
        self.generator = ReportGenerator()
        self.app = None
        self.runner = None
        self.site = None
        
        # Storage for generated reports
        self.reports = {}
        self.report_counter = 0
    
    async def start(self):
        """Start the reporting API server."""
        if not web:
            self.logger.warning("aiohttp not available, reporting API disabled")
            return
        
        if not self.config.report_api_enabled:
            return
        
        self.app = web.Application()
        self._setup_routes()
        
        self.runner = web.AppRunner(self.app)
        await self.runner.setup()
        
        self.site = web.TCPSite(self.runner, 'localhost', self.config.report_api_port)
        await self.site.start()
        
        self.logger.info(f"Reporting API started on port {self.config.report_api_port}")
    
    async def stop(self):
        """Stop the reporting API server."""
        if self.site:
            await self.site.stop()
        if self.runner:
            await self.runner.cleanup()
        
        self.logger.info("Reporting API stopped")
    
    def _setup_routes(self):
        """Setup API routes."""
        self.app.router.add_get('/api/reports', self.list_reports)
        self.app.router.add_get('/api/reports/{report_id}', self.get_report)
        self.app.router.add_post('/api/reports/generate', self.generate_report_endpoint)
        self.app.router.add_get('/api/status', self.get_status)
    
    async def list_reports(self, request):
        """List all available reports."""
        reports_list = []
        for report_id, report_data in self.reports.items():
            reports_list.append({
                "id": report_id,
                "format": report_data["format"],
                "target": report_data["metadata"]["target"],
                "generated_at": report_data["metadata"]["generated_at"],
                "size": len(report_data["content"])
            })
        
        return web.json_response({"reports": reports_list})
    
    async def get_report(self, request):
        """Get a specific report."""
        report_id = request.match_info['report_id']
        
        if report_id not in self.reports:
            return web.json_response({"error": "Report not found"}, status=404)
        
        report_data = self.reports[report_id]
        
        if report_data["format"] == "json":
            return web.Response(
                text=report_data["content"],
                content_type="application/json"
            )
        elif report_data["format"] == "html":
            return web.Response(
                text=report_data["content"],
                content_type="text/html"
            )
        elif report_data["format"] == "markdown":
            return web.Response(
                text=report_data["content"],
                content_type="text/markdown"
            )
        elif report_data["format"] == "pdf":
            return web.Response(
                body=report_data["content"],
                content_type="application/pdf"
            )
        else:
            return web.Response(text=report_data["content"])
    
    async def generate_report_endpoint(self, request):
        """Generate a new report via API."""
        try:
            data = await request.json()
            
            results = data.get("results", {})
            formats = data.get("formats", ["json"])
            
            report_ids = {}
            
            for format_type in formats:
                report_id = await self._generate_and_store_report(results, format_type)
                report_ids[format_type] = report_id
            
            return web.json_response({
                "success": True,
                "report_ids": report_ids
            })
            
        except Exception as e:
            return web.json_response({
                "error": str(e)
            }, status=400)
    
    async def get_status(self, request):
        """Get API status."""
        return web.json_response({
            "status": "running",
            "reports_count": len(self.reports),
            "supported_formats": ["json", "html", "markdown", "pdf"]
        })
    
    async def generate_reports(self, results: Dict[str, Any]) -> Dict[str, str]:
        """Generate reports in all configured formats."""
        report_ids = {}
        
        for format_type in self.config.report_formats:
            try:
                report_id = await self._generate_and_store_report(results, format_type)
                report_ids[format_type] = report_id
            except Exception as e:
                self.logger.error(f"Failed to generate {format_type} report: {e}")
        
        return report_ids
    
    async def _generate_and_store_report(self, results: Dict[str, Any], format_type: str) -> str:
        """Generate and store a report in the specified format."""
        self.report_counter += 1
        report_id = f"report_{self.report_counter}_{format_type}"
        
        # Generate report content
        if format_type == "json":
            content = await self.generator.generate_json_report(results)
        elif format_type == "html":
            content = await self.generator.generate_html_report(results)
        elif format_type == "markdown":
            content = await self.generator.generate_markdown_report(results)
        elif format_type == "pdf":
            content = await self.generator.generate_pdf_report(results)
        else:
            raise ValueError(f"Unsupported format: {format_type}")
        
        # Store report
        self.reports[report_id] = {
            "id": report_id,
            "format": format_type,
            "content": content,
            "metadata": {
                "target": results.get("target", "Unknown"),
                "generated_at": datetime.now().isoformat(),
                "assessment_id": results.get("id")
            }
        }
        
        self.logger.info(f"Generated {format_type} report: {report_id}")
        return report_id