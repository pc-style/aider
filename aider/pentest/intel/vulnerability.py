"""
Vulnerability intelligence module for CVE/CVSS feed synchronization.
Maps findings to known exploits and calculates composite risk scores.
"""

import asyncio
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from pathlib import Path

try:
    import aiohttp
except ImportError:
    aiohttp = None

from ..config import PentestConfig


class VulnerabilityIntel:
    """Manages vulnerability intelligence and CVE feed integration."""
    
    def __init__(self, config: PentestConfig):
        self.config = config
        self.logger = logging.getLogger("intel.vulnerability")
        self.cve_cache = {}
        self.exploit_db = {}
        self.cache_file = Path("./vuln_cache.json")
        self.last_update = None
        
        # CVE API endpoints
        self.cve_api_base = "https://services.nvd.nist.gov/rest/json"
        self.exploit_db_api = "https://exploit-db.com/api/v1"
        
    async def initialize(self):
        """Initialize vulnerability intelligence system."""
        self.logger.info("Initializing vulnerability intelligence...")
        
        # Load cached data
        await self._load_cache()
        
        # Update feeds if cache is stale
        if self._should_update_feeds():
            await self._update_feeds()
        
        self.logger.info("Vulnerability intelligence initialized")
    
    def _should_update_feeds(self) -> bool:
        """Check if feeds should be updated."""
        if not self.last_update:
            return True
        
        # Update if cache is older than 24 hours
        time_diff = datetime.now() - self.last_update
        return time_diff > timedelta(hours=24)
    
    async def _load_cache(self):
        """Load cached vulnerability data."""
        try:
            if self.cache_file.exists():
                with open(self.cache_file, 'r') as f:
                    cache_data = json.load(f)
                    self.cve_cache = cache_data.get('cve_cache', {})
                    self.exploit_db = cache_data.get('exploit_db', {})
                    
                    if 'last_update' in cache_data:
                        self.last_update = datetime.fromisoformat(cache_data['last_update'])
                    
                self.logger.info(f"Loaded {len(self.cve_cache)} CVEs from cache")
        except Exception as e:
            self.logger.error(f"Failed to load cache: {e}")
    
    async def _save_cache(self):
        """Save vulnerability data to cache."""
        try:
            cache_data = {
                'cve_cache': self.cve_cache,
                'exploit_db': self.exploit_db,
                'last_update': datetime.now().isoformat()
            }
            
            with open(self.cache_file, 'w') as f:
                json.dump(cache_data, f, indent=2)
                
        except Exception as e:
            self.logger.error(f"Failed to save cache: {e}")
    
    async def _update_feeds(self):
        """Update CVE and exploit feeds."""
        self.logger.info("Updating vulnerability feeds...")
        
        try:
            # Update CVE feeds (simplified for demo)
            await self._update_cve_feed()
            
            # Update exploit database (simplified for demo)
            await self._update_exploit_feed()
            
            self.last_update = datetime.now()
            await self._save_cache()
            
            self.logger.info("Vulnerability feeds updated successfully")
            
        except Exception as e:
            self.logger.error(f"Failed to update feeds: {e}")
    
    async def _update_cve_feed(self):
        """Update CVE feed from NVD."""
        # Simplified implementation - in production would use proper NVD API
        
        # Mock CVE data for demonstration
        mock_cves = {
            "CVE-2021-44228": {
                "cvss_v3_score": 10.0,
                "severity": "CRITICAL",
                "description": "Apache Log4j2 Remote Code Execution",
                "exploitability": 9.8,
                "vector": "NETWORK",
                "published": "2021-12-10"
            },
            "CVE-2021-4034": {
                "cvss_v3_score": 7.8,
                "severity": "HIGH", 
                "description": "PwnKit Local Privilege Escalation",
                "exploitability": 8.5,
                "vector": "LOCAL",
                "published": "2022-01-25"
            },
            "CVE-2020-1472": {
                "cvss_v3_score": 10.0,
                "severity": "CRITICAL",
                "description": "Zerologon Domain Controller Vulnerability",
                "exploitability": 9.0,
                "vector": "NETWORK",
                "published": "2020-08-11"
            },
            "CVE-2019-0708": {
                "cvss_v3_score": 9.8,
                "severity": "CRITICAL",
                "description": "BlueKeep RDP Remote Code Execution",
                "exploitability": 8.8,
                "vector": "NETWORK", 
                "published": "2019-05-14"
            }
        }
        
        self.cve_cache.update(mock_cves)
        self.logger.info(f"Updated CVE cache with {len(mock_cves)} entries")
    
    async def _update_exploit_feed(self):
        """Update exploit database."""
        # Simplified implementation - in production would use real exploit-db API
        
        mock_exploits = {
            "CVE-2021-44228": {
                "exploit_available": True,
                "exploit_reliability": "Excellent",
                "metasploit_modules": ["exploit/multi/http/log4shell_header_injection"],
                "public_exploits": 15,
                "weaponized": True
            },
            "CVE-2021-4034": {
                "exploit_available": True,
                "exploit_reliability": "Excellent",
                "metasploit_modules": ["exploit/linux/local/polkit_pkexec"],
                "public_exploits": 8,
                "weaponized": True
            },
            "CVE-2020-1472": {
                "exploit_available": True,
                "exploit_reliability": "Good",
                "metasploit_modules": ["exploit/windows/dcerpc/ms20_069_zerologon"],
                "public_exploits": 12,
                "weaponized": True
            },
            "CVE-2019-0708": {
                "exploit_available": True,
                "exploit_reliability": "Average",
                "metasploit_modules": ["exploit/windows/rdp/cve_2019_0708_bluekeep_rce"],
                "public_exploits": 6,
                "weaponized": False
            }
        }
        
        self.exploit_db.update(mock_exploits)
        self.logger.info(f"Updated exploit database with {len(mock_exploits)} entries")
    
    async def enrich_findings(self, findings: Dict[str, Any]) -> Dict[str, Any]:
        """Enrich assessment findings with vulnerability intelligence."""
        self.logger.info("Enriching findings with vulnerability intelligence...")
        
        enriched_findings = findings.copy()
        
        # Process each phase
        for phase in enriched_findings.get('phases', []):
            for task_result in phase.get('task_results', []):
                if 'findings' in task_result:
                    enriched_findings_list = []
                    
                    for finding in task_result['findings']:
                        enriched_finding = await self._enrich_single_finding(finding)
                        enriched_findings_list.append(enriched_finding)
                    
                    task_result['findings'] = enriched_findings_list
        
        # Add intelligence summary
        enriched_findings['intelligence_summary'] = await self._generate_intelligence_summary(
            enriched_findings
        )
        
        return enriched_findings
    
    async def _enrich_single_finding(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Enrich a single finding with vulnerability data."""
        enriched = finding.copy()
        
        # Look for CVE information
        cve_id = finding.get('cve') or finding.get('vulnerability')
        
        if cve_id and cve_id in self.cve_cache:
            cve_data = self.cve_cache[cve_id]
            enriched.update({
                'cvss_score': cve_data.get('cvss_v3_score', 0.0),
                'severity': cve_data.get('severity', 'UNKNOWN'),
                'description': cve_data.get('description', ''),
                'exploitability_score': cve_data.get('exploitability', 0.0),
                'vector': cve_data.get('vector', 'UNKNOWN'),
                'published_date': cve_data.get('published', '')
            })
            
            # Add exploit information if available
            if cve_id in self.exploit_db:
                exploit_data = self.exploit_db[cve_id]
                enriched.update({
                    'exploit_available': exploit_data.get('exploit_available', False),
                    'exploit_reliability': exploit_data.get('exploit_reliability', 'Unknown'),
                    'metasploit_modules': exploit_data.get('metasploit_modules', []),
                    'public_exploits': exploit_data.get('public_exploits', 0),
                    'weaponized': exploit_data.get('weaponized', False)
                })
            
            # Calculate composite risk score
            enriched['composite_risk_score'] = self._calculate_composite_score(enriched)
        
        # Identify potential service vulnerabilities
        if 'service' in finding and 'version' in finding:
            service_vulns = await self._identify_service_vulnerabilities(
                finding['service'], 
                finding['version']
            )
            if service_vulns:
                enriched['potential_vulnerabilities'] = service_vulns
        
        return enriched
    
    def _calculate_composite_score(self, finding: Dict[str, Any]) -> float:
        """Calculate composite risk score using formula: R = α * CVSS + β * Exploitability."""
        cvss_score = finding.get('cvss_score', 0.0)
        exploitability = finding.get('exploitability_score', 0.0)
        
        # Weight factors (α and β from requirements)
        alpha = 0.7  # CVSS weight
        beta = 0.3   # Exploitability weight
        
        composite_score = alpha * cvss_score + beta * exploitability
        
        # Apply multipliers for additional factors
        if finding.get('exploit_available'):
            composite_score *= 1.2
        
        if finding.get('weaponized'):
            composite_score *= 1.3
        
        if finding.get('vector') == 'NETWORK':
            composite_score *= 1.1
        
        return min(composite_score, 10.0)  # Cap at 10.0
    
    async def _identify_service_vulnerabilities(self, service: str, version: str) -> List[Dict[str, Any]]:
        """Identify known vulnerabilities for a service/version."""
        vulnerabilities = []
        
        # Simplified service vulnerability mapping
        service_vulns = {
            "ssh": {
                "OpenSSH 7.4": ["CVE-2016-10009", "CVE-2016-10010"],
                "OpenSSH 6.6": ["CVE-2016-0777", "CVE-2016-0778"]
            },
            "apache": {
                "Apache 2.4.6": ["CVE-2017-15710", "CVE-2017-15715"],
                "Apache 2.2.15": ["CVE-2017-9798", "CVE-2011-3192"]
            },
            "mysql": {
                "MySQL 5.5": ["CVE-2016-6663", "CVE-2016-6664"],
                "MySQL 5.6": ["CVE-2018-2767", "CVE-2018-2755"]
            }
        }
        
        service_lower = service.lower()
        if service_lower in service_vulns and version in service_vulns[service_lower]:
            for cve in service_vulns[service_lower][version]:
                if cve in self.cve_cache:
                    vuln_data = self.cve_cache[cve].copy()
                    vuln_data['cve'] = cve
                    vulnerabilities.append(vuln_data)
        
        return vulnerabilities
    
    async def _generate_intelligence_summary(self, findings: Dict[str, Any]) -> Dict[str, Any]:
        """Generate intelligence summary for the assessment."""
        summary = {
            "total_vulnerabilities": 0,
            "severity_breakdown": {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0},
            "exploitable_vulnerabilities": 0,
            "weaponized_exploits": 0,
            "highest_risk_score": 0.0,
            "top_risks": [],
            "recommendations": []
        }
        
        all_findings = []
        for phase in findings.get('phases', []):
            for task_result in phase.get('task_results', []):
                all_findings.extend(task_result.get('findings', []))
        
        # Analyze findings
        for finding in all_findings:
            if 'cvss_score' in finding:
                summary["total_vulnerabilities"] += 1
                
                severity = finding.get('severity', 'UNKNOWN')
                if severity in summary["severity_breakdown"]:
                    summary["severity_breakdown"][severity] += 1
                
                if finding.get('exploit_available'):
                    summary["exploitable_vulnerabilities"] += 1
                
                if finding.get('weaponized'):
                    summary["weaponized_exploits"] += 1
                
                risk_score = finding.get('composite_risk_score', 0.0)
                if risk_score > summary["highest_risk_score"]:
                    summary["highest_risk_score"] = risk_score
                
                # Collect top risks
                if risk_score >= 7.0:
                    summary["top_risks"].append({
                        "cve": finding.get('cve', 'Unknown'),
                        "description": finding.get('description', ''),
                        "risk_score": risk_score,
                        "severity": severity
                    })
        
        # Sort top risks by score
        summary["top_risks"].sort(key=lambda x: x["risk_score"], reverse=True)
        summary["top_risks"] = summary["top_risks"][:10]  # Top 10
        
        # Generate recommendations
        summary["recommendations"] = self._generate_recommendations(summary)
        
        return summary
    
    def _generate_recommendations(self, summary: Dict[str, Any]) -> List[str]:
        """Generate security recommendations based on findings."""
        recommendations = []
        
        if summary["severity_breakdown"]["CRITICAL"] > 0:
            recommendations.append(
                f"Immediately address {summary['severity_breakdown']['CRITICAL']} critical vulnerabilities"
            )
        
        if summary["exploitable_vulnerabilities"] > 0:
            recommendations.append(
                f"Prioritize {summary['exploitable_vulnerabilities']} vulnerabilities with available exploits"
            )
        
        if summary["weaponized_exploits"] > 0:
            recommendations.append(
                f"Apply emergency patches for {summary['weaponized_exploits']} weaponized vulnerabilities"
            )
        
        if summary["highest_risk_score"] >= 9.0:
            recommendations.append(
                "Highest risk score exceeds 9.0 - consider isolating affected systems"
            )
        
        if summary["severity_breakdown"]["HIGH"] > 5:
            recommendations.append(
                "High number of high-severity vulnerabilities detected - implement vulnerability management program"
            )
        
        return recommendations
    
    async def get_cve_details(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """Get detailed information for a specific CVE."""
        if cve_id in self.cve_cache:
            details = self.cve_cache[cve_id].copy()
            
            # Add exploit information if available
            if cve_id in self.exploit_db:
                details.update(self.exploit_db[cve_id])
            
            return details
        
        return None
    
    async def search_vulnerabilities(self, criteria: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Search vulnerabilities based on criteria."""
        results = []
        
        min_score = criteria.get('min_cvss_score', 0.0)
        max_score = criteria.get('max_cvss_score', 10.0)
        severity = criteria.get('severity')
        has_exploit = criteria.get('has_exploit')
        
        for cve_id, cve_data in self.cve_cache.items():
            # Check CVSS score range
            cvss_score = cve_data.get('cvss_v3_score', 0.0)
            if not (min_score <= cvss_score <= max_score):
                continue
            
            # Check severity
            if severity and cve_data.get('severity') != severity:
                continue
            
            # Check exploit availability
            if has_exploit is not None:
                exploit_available = cve_id in self.exploit_db and self.exploit_db[cve_id].get('exploit_available', False)
                if has_exploit != exploit_available:
                    continue
            
            result = cve_data.copy()
            result['cve'] = cve_id
            
            if cve_id in self.exploit_db:
                result.update(self.exploit_db[cve_id])
            
            results.append(result)
        
        # Sort by CVSS score (descending)
        results.sort(key=lambda x: x.get('cvss_v3_score', 0.0), reverse=True)
        
        return results