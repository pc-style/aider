"""
Graph database for storing hosts, ports, vulnerabilities, credentials and relationships.
Enables path-finding for lateral movement and real-time risk propagation.
"""

import asyncio
import json
import logging
import sqlite3
from datetime import datetime
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path

from ..config import PentestConfig


class GraphNode:
    """Represents a node in the pentest graph."""
    
    def __init__(self, node_id: str, node_type: str, properties: Dict[str, Any]):
        self.id = node_id
        self.type = node_type  # host, port, vulnerability, credential, service
        self.properties = properties
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "type": self.type,
            "properties": self.properties,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat()
        }


class GraphEdge:
    """Represents a relationship between nodes in the pentest graph."""
    
    def __init__(self, source_id: str, target_id: str, relationship: str, 
                 properties: Optional[Dict[str, Any]] = None):
        self.source_id = source_id
        self.target_id = target_id
        self.relationship = relationship  # has_port, has_vulnerability, uses_credential, etc.
        self.properties = properties or {}
        self.created_at = datetime.now()
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "source_id": self.source_id,
            "target_id": self.target_id,
            "relationship": self.relationship,
            "properties": self.properties,
            "created_at": self.created_at.isoformat()
        }


class GraphDatabase:
    """SQLite-based graph database for pentesting data storage."""
    
    def __init__(self, config: PentestConfig, db_path: str = "./pentest_graph.db"):
        self.config = config
        self.db_path = db_path
        self.logger = logging.getLogger("graph.database")
        self.connection = None
        
    async def initialize(self):
        """Initialize the graph database."""
        self.connection = sqlite3.connect(self.db_path)
        self.connection.row_factory = sqlite3.Row  # Enable column access by name
        
        # Create tables
        await self._create_tables()
        self.logger.info("Graph database initialized")
    
    async def _create_tables(self):
        """Create database tables for graph storage."""
        cursor = self.connection.cursor()
        
        # Nodes table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS nodes (
                id TEXT PRIMARY KEY,
                type TEXT NOT NULL,
                properties TEXT NOT NULL,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL
            )
        ''')
        
        # Edges table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS edges (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                source_id TEXT NOT NULL,
                target_id TEXT NOT NULL,
                relationship TEXT NOT NULL,
                properties TEXT NOT NULL,
                created_at TEXT NOT NULL,
                FOREIGN KEY (source_id) REFERENCES nodes (id),
                FOREIGN KEY (target_id) REFERENCES nodes (id)
            )
        ''')
        
        # Assessment results table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS assessments (
                id TEXT PRIMARY KEY,
                target TEXT NOT NULL,
                results TEXT NOT NULL,
                created_at TEXT NOT NULL
            )
        ''')
        
        # Create indexes for performance
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_nodes_type ON nodes (type)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_edges_source ON edges (source_id)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_edges_target ON edges (target_id)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_edges_relationship ON edges (relationship)')
        
        self.connection.commit()
    
    async def add_node(self, node: GraphNode) -> bool:
        """Add a node to the graph."""
        try:
            cursor = self.connection.cursor()
            cursor.execute('''
                INSERT OR REPLACE INTO nodes (id, type, properties, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?)
            ''', (
                node.id,
                node.type,
                json.dumps(node.properties),
                node.created_at.isoformat(),
                node.updated_at.isoformat()
            ))
            self.connection.commit()
            return True
        except Exception as e:
            self.logger.error(f"Failed to add node {node.id}: {e}")
            return False
    
    async def add_edge(self, edge: GraphEdge) -> bool:
        """Add an edge to the graph."""
        try:
            cursor = self.connection.cursor()
            cursor.execute('''
                INSERT INTO edges (source_id, target_id, relationship, properties, created_at)
                VALUES (?, ?, ?, ?, ?)
            ''', (
                edge.source_id,
                edge.target_id,
                edge.relationship,
                json.dumps(edge.properties),
                edge.created_at.isoformat()
            ))
            self.connection.commit()
            return True
        except Exception as e:
            self.logger.error(f"Failed to add edge {edge.source_id}->{edge.target_id}: {e}")
            return False
    
    async def add_target(self, target: str) -> str:
        """Add a target host to the graph."""
        target_id = f"host_{target.replace('.', '_').replace(':', '_')}"
        
        host_node = GraphNode(
            node_id=target_id,
            node_type="host",
            properties={
                "ip_address": target,
                "hostname": target,
                "status": "unknown",
                "os": "unknown",
                "risk_score": 0
            }
        )
        
        await self.add_node(host_node)
        return target_id
    
    async def add_port(self, host_id: str, port: int, service: str, state: str = "open") -> str:
        """Add a port to a host."""
        port_id = f"{host_id}_port_{port}"
        
        port_node = GraphNode(
            node_id=port_id,
            node_type="port",
            properties={
                "port_number": port,
                "service": service,
                "state": state,
                "banner": "",
                "version": ""
            }
        )
        
        await self.add_node(port_node)
        
        # Create relationship between host and port
        edge = GraphEdge(host_id, port_id, "has_port")
        await self.add_edge(edge)
        
        return port_id
    
    async def add_vulnerability(self, target_id: str, vuln_data: Dict[str, Any]) -> str:
        """Add a vulnerability to a target."""
        vuln_id = f"vuln_{vuln_data.get('cve', 'unknown')}_{target_id}"
        
        vuln_node = GraphNode(
            node_id=vuln_id,
            node_type="vulnerability",
            properties={
                "cve": vuln_data.get("cve", ""),
                "cvss_score": vuln_data.get("cvss_score", 0.0),
                "severity": vuln_data.get("severity", "unknown"),
                "description": vuln_data.get("description", ""),
                "exploit_available": vuln_data.get("exploit_available", False),
                "exploitability_score": vuln_data.get("exploitability_score", 0.0)
            }
        )
        
        await self.add_node(vuln_node)
        
        # Create relationship between target and vulnerability
        edge = GraphEdge(target_id, vuln_id, "has_vulnerability")
        await self.add_edge(edge)
        
        return vuln_id
    
    async def add_credential(self, username: str, password: str, service: str, 
                           host_id: str) -> str:
        """Add discovered credentials."""
        cred_id = f"cred_{username}_{service}_{host_id}"
        
        cred_node = GraphNode(
            node_id=cred_id,
            node_type="credential",
            properties={
                "username": username,
                "password": password,  # Should be encrypted in production
                "service": service,
                "type": "password",
                "valid": True
            }
        )
        
        await self.add_node(cred_node)
        
        # Create relationship between host and credential
        edge = GraphEdge(host_id, cred_id, "uses_credential")
        await self.add_edge(edge)
        
        return cred_id
    
    async def get_nodes_by_type(self, node_type: str) -> List[Dict[str, Any]]:
        """Get all nodes of a specific type."""
        cursor = self.connection.cursor()
        cursor.execute('SELECT * FROM nodes WHERE type = ?', (node_type,))
        rows = cursor.fetchall()
        
        nodes = []
        for row in rows:
            node_dict = dict(row)
            node_dict['properties'] = json.loads(node_dict['properties'])
            nodes.append(node_dict)
        
        return nodes
    
    async def get_node_relationships(self, node_id: str) -> List[Dict[str, Any]]:
        """Get all relationships for a node."""
        cursor = self.connection.cursor()
        cursor.execute('''
            SELECT e.*, n1.type as source_type, n2.type as target_type
            FROM edges e
            JOIN nodes n1 ON e.source_id = n1.id
            JOIN nodes n2 ON e.target_id = n2.id
            WHERE e.source_id = ? OR e.target_id = ?
        ''', (node_id, node_id))
        
        relationships = []
        for row in cursor.fetchall():
            rel_dict = dict(row)
            rel_dict['properties'] = json.loads(rel_dict['properties'])
            relationships.append(rel_dict)
        
        return relationships
    
    async def find_lateral_movement_paths(self, start_host: str, target_host: str) -> List[List[str]]:
        """Find potential lateral movement paths between hosts."""
        # Simplified path finding algorithm - in production would use more sophisticated graph algorithms
        paths = []
        
        # Get all hosts
        hosts = await self.get_nodes_by_type("host")
        
        # Get all credentials that could enable lateral movement
        credentials = await self.get_nodes_by_type("credential")
        
        # Simple path: if we have credentials on one host, we might be able to use them on another
        for cred in credentials:
            cred_props = cred['properties']
            if cred_props.get('valid') and cred_props.get('service') in ['ssh', 'rdp', 'smb']:
                # This is a simplified example - real implementation would be more complex
                paths.append([start_host, f"credential_{cred['id']}", target_host])
        
        return paths
    
    async def calculate_risk_propagation(self, node_id: str) -> float:
        """Calculate risk score propagation through the graph."""
        # Get the node
        cursor = self.connection.cursor()
        cursor.execute('SELECT * FROM nodes WHERE id = ?', (node_id,))
        node_row = cursor.fetchone()
        
        if not node_row:
            return 0.0
        
        node = dict(node_row)
        node['properties'] = json.loads(node['properties'])
        
        base_risk = 0.0
        
        # Calculate base risk based on node type
        if node['type'] == 'vulnerability':
            cvss_score = node['properties'].get('cvss_score', 0.0)
            exploitability = node['properties'].get('exploitability_score', 0.0)
            # Risk formula: R = α * CVSS + β * Exploitability
            alpha, beta = 0.7, 0.3
            base_risk = alpha * cvss_score + beta * exploitability
        elif node['type'] == 'host':
            # Host risk is aggregate of its vulnerabilities
            relationships = await self.get_node_relationships(node_id)
            vuln_risks = []
            for rel in relationships:
                if rel['relationship'] == 'has_vulnerability':
                    vuln_risk = await self.calculate_risk_propagation(rel['target_id'])
                    vuln_risks.append(vuln_risk)
            
            if vuln_risks:
                base_risk = max(vuln_risks)  # Highest vulnerability risk
        
        return min(base_risk, 10.0)  # Cap at 10.0
    
    async def store_assessment_results(self, assessment_id: str, results: Dict[str, Any]):
        """Store complete assessment results."""
        try:
            cursor = self.connection.cursor()
            cursor.execute('''
                INSERT OR REPLACE INTO assessments (id, target, results, created_at)
                VALUES (?, ?, ?, ?)
            ''', (
                assessment_id,
                results.get('target', ''),
                json.dumps(results),
                datetime.now().isoformat()
            ))
            self.connection.commit()
            
            # Also update graph with findings
            await self._update_graph_from_results(results)
            
        except Exception as e:
            self.logger.error(f"Failed to store assessment results: {e}")
    
    async def _update_graph_from_results(self, results: Dict[str, Any]):
        """Update graph database with assessment findings."""
        target = results.get('target')
        if not target:
            return
        
        target_id = await self.add_target(target)
        
        # Process findings from assessment phases
        for phase in results.get('phases', []):
            for task_result in phase.get('task_results', []):
                findings = task_result.get('findings', [])
                
                for finding in findings:
                    if 'port' in finding:
                        await self.add_port(
                            target_id,
                            finding['port'],
                            finding.get('service', 'unknown'),
                            finding.get('state', 'open')
                        )
                    
                    if 'vulnerability' in finding:
                        await self.add_vulnerability(target_id, finding)
                    
                    if 'username' in finding and 'password' in finding:
                        await self.add_credential(
                            finding['username'],
                            finding['password'],
                            finding.get('service', 'unknown'),
                            target_id
                        )
    
    async def get_statistics(self) -> Dict[str, Any]:
        """Get database statistics."""
        cursor = self.connection.cursor()
        
        stats = {}
        
        # Count nodes by type
        cursor.execute('SELECT type, COUNT(*) as count FROM nodes GROUP BY type')
        node_counts = {row[0]: row[1] for row in cursor.fetchall()}
        stats['nodes'] = node_counts
        
        # Count edges by relationship
        cursor.execute('SELECT relationship, COUNT(*) as count FROM edges GROUP BY relationship')
        edge_counts = {row[0]: row[1] for row in cursor.fetchall()}
        stats['relationships'] = edge_counts
        
        # Count assessments
        cursor.execute('SELECT COUNT(*) FROM assessments')
        stats['assessments'] = cursor.fetchone()[0]
        
        return stats
    
    async def close(self):
        """Close the database connection."""
        if self.connection:
            self.connection.close()
            self.logger.info("Graph database connection closed")