"""
PentestCommands: command extensions for pentest mode.
"""

from aider.commands import Commands
from . import ETHICS_DISCLAIMER
from . import utils
from .recon import ReconManager
from .vulnerability import VulnerabilityManager
from .report import ReportManager
from .osint import OSINTManager
from .exploit import ExploitManager
from .social import SocialEngineeringManager

class PentestCommands(Commands):
    """
    Command set for PentestAider security tooling.
    """

    def __init__(self, io, coder, **kwargs):
        super().__init__(io, coder, **kwargs)
        self.args = kwargs.get("args")
        self.scope = utils.load_scope(getattr(self.args, "scope_file", "scope.txt"))
        self.allow_exec = getattr(self.args, "unsafe_exec", False)
        self.last_recon = None
        self.last_vuln = None
        self.last_exploit = None
        self.last_social = None
        # Show ethics disclaimer once per session if --yes/--yes-always is not set
        if not getattr(self.args, "yes", False) and not getattr(self.args, "yes_always", False):
            io.tool_output(ETHICS_DISCLAIMER)
            ok = io.confirm_ask("I confirm I am authorized to test these targets.")
            if not ok:
                io.tool_error("Ethics disclaimer not accepted. Exiting PentestAider.")
                import sys
                sys.exit(1)

    def cmd_recon(self, args):
        """
        Run reconnaissance tasks on target(s).

        Usage: /recon <target1> [target2 ...]
        """
        targets = args.split()
        if not targets:
            self.io.tool_error("No targets provided for recon.")
            return
        for target in targets:
            if not utils.in_scope(target, self.scope):
                self.io.tool_error(f"Target '{target}' is not in scope.")
                continue
            recon_mgr = ReconManager(self.io, self.allow_exec)
            recon_mgr.basic_recon(target)
            results = recon_mgr.get_results()
            if results:
                self.io.tool_output("==== Recon Summary ====")
                for tool, snippet in results:
                    self.io.tool_output(f"[{tool}]")
                    lines = snippet.splitlines()
                    for line in lines[:5]:
                        self.io.tool_output(line)
                    if len(lines) > 5:
                        self.io.tool_output("... (truncated) ...")
                self.last_recon = results

    def cmd_scan(self, args):
        """
        Perform vulnerability assessment on the specified target(s).
        """
        targets = args.split()
        if not targets:
            self.io.tool_error("No targets provided for scan.")
            return
        for target in targets:
            if not utils.in_scope(target, self.scope):
                self.io.tool_error(f"Target '{target}' is not in scope.")
                continue
            vuln_mgr = VulnerabilityManager(self.io, self.allow_exec)
            vuln_mgr.basic_scan(target)
            results = vuln_mgr.get_results()
            if results:
                self.io.tool_output("==== Vulnerability Scan Summary ====")
                for tool, snippet in results:
                    self.io.tool_output(f"[{tool}]")
                    lines = snippet.splitlines()
                    for line in lines[:5]:
                        self.io.tool_output(line)
                    if len(lines) > 5:
                        self.io.tool_output("... (truncated) ...")
                self.last_vuln = results

    def cmd_osint(self, args):
        """
        Run basic OSINT (whois, DNS, Shodan) on target(s).

        Usage: /osint <target1> [target2 ...]
        """
        targets = args.split()
        if not targets:
            self.io.tool_error("No targets provided for OSINT.")
            return
        for target in targets:
            if not utils.in_scope(target, self.scope):
                self.io.tool_error(f"Target '{target}' is not in scope.")
                continue
            OSINTManager(self.io, self.allow_exec).basic_osint(target)

    def cmd_exploit(self, args):
        """
        Generate or simulate exploit payloads for given target(s).

        Usage:
            /exploit reverse <bash|python|nc> <lhost> <lport>
            /exploit msf <payload_type> <lhost> <lport>
        """
        tokens = args.strip().split()
        if not tokens:
            self.io.tool_error("No exploit command given.")
            return
        mgr = ExploitManager(self.io, self.allow_exec)
        if tokens[0] == "reverse" and len(tokens) == 4:
            _, shell_type, lhost, lport = tokens
            payload = mgr.generate_reverse_shell(shell_type, lhost, lport)
            self.io.tool_output(f"Reverse shell ({shell_type}):\n{payload}")
        elif tokens[0] == "msf" and len(tokens) == 4:
            _, payload_type, lhost, lport = tokens
            mgr.metasploit_payload(payload_type, lhost, lport)
        else:
            self.io.tool_error(
                "Usage: /exploit reverse <bash|python|nc> <lhost> <lport> OR /exploit msf <payload_type> <lhost> <lport>"
            )
            return
        results = mgr.get_results()
        if results:
            self.io.tool_output("==== Exploit Summary ====")
            for tool, snippet in results:
                self.io.tool_output(f"[{tool}]")
                lines = snippet.splitlines()
                for line in lines[:5]:
                    self.io.tool_output(line)
                if len(lines) > 5:
                    self.io.tool_output("... (truncated) ...")
            self.last_exploit = results

    def cmd_social(self, args):
        """
        Simulate social engineering scenarios.

        Usage:
            /social email <template> <target_name> <org>
            /social pretext <role> <target_person>
            /social tip
        """
        tokens = args.strip().split()
        mgr = SocialEngineeringManager(self.io)
        if not tokens:
            self.io.tool_error("No social engineering subcommand given.")
            return
        if tokens[0] == "email" and len(tokens) >= 4:
            _, template, target_name, org = tokens[:4]
            sender = "IT Support"
            if len(tokens) > 4:
                sender = " ".join(tokens[4:])
            email = mgr.generate_phishing_email(template, target_name, org, sender)
            self.io.tool_output(email)
        elif tokens[0] == "pretext" and len(tokens) == 3:
            _, role, target_person = tokens
            scenario = mgr.pretexting_scenario(role, target_person)
            self.io.tool_output(scenario)
        elif tokens[0] == "tip":
            tip = mgr.awareness_training_tip()
            self.io.tool_output(tip)
        else:
            self.io.tool_error(
                "Usage: /social email <template> <target_name> <org> [sender] | /social pretext <role> <target_person> | /social tip"
            )
            return
        results = mgr.get_results()
        if results:
            self.io.tool_output("==== Social Engineering Summary ====")
            for tool, snippet in results:
                self.io.tool_output(f"[{tool}] {snippet}")
            self.last_social = results

    def cmd_dashboard(self, args):
        """
        Show a dashboard summary of the latest Recon, Scan, Exploit and Social results.
        """
        from .utils import colorize
        categories = [
            ("Recon", self.last_recon, "blue"),
            ("Scan", self.last_vuln, "green"),
            ("Exploit", self.last_exploit, "magenta"),
            ("Social", self.last_social, "yellow"),
        ]
        for label, data, color in categories:
            header = colorize(self.io, f"== {label} ==", color)
            self.io.tool_output(header)
            if not data:
                self.io.tool_output("No recent results.")
            else:
                self.io.tool_output(f"Count: {len(data)}")
                self.io.tool_output(f"First tool: {data[0][0]}")
            self.io.tool_output("")

    def cmd_reportgen(self, args):
        """
        Generate a pentest report.
        """
        if not (self.last_recon or self.last_vuln or self.last_exploit or self.last_social):
            self.io.tool_error("No evidence/results to report. Run recon/scan/exploit/social first.")
            return
        try:
            report_mgr = ReportManager(self.io)
            markdown = report_mgr.aggregate_results(
                self.last_recon or [],
                self.last_vuln or [],
                self.last_exploit or [],
                self.last_social or [],
            )
            report_path = report_mgr.generate_report(
                self.last_recon or [],
                self.last_vuln or [],
                self.last_exploit or [],
                self.last_social or [],
            )
            self.io.tool_output(f"Report saved: {report_path}")
        except Exception as ex:
            self.io.tool_output(f"Failed to generate report: {ex}")

    def cmd_pentest_mode(self, args):
        """
        Toggle between pentest and normal mode (stub).
        """
        self.io.tool_output("Pentest mode is currently enabled. (stub)")