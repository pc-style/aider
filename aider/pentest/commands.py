"""
PentestCommands: command extensions for pentest mode.
"""

from aider.commands import Commands
from . import ETHICS_DISCLAIMER
from . import utils
from .recon import ReconManager
from .vulnerability import VulnerabilityManager
from .report import ReportManager
from .osint import OSINTManager
from .exploit import ExploitManager

class PentestCommands(Commands):
    """
    Command set for PentestAider security tooling.
    """

    def __init__(self, io, coder, **kwargs):
        super().__init__(io, coder, **kwargs)
        self.args = kwargs.get("args")
        self.scope = utils.load_scope(getattr(self.args, "scope_file", "scope.txt"))
        self.allow_exec = getattr(self.args, "unsafe_exec", False)
        # Show ethics disclaimer once per session if --yes/--yes-always is not set
        if not getattr(self.args, "yes", False) and not getattr(self.args, "yes_always", False):
            io.tool_output(ETHICS_DISCLAIMER)
            ok = io.confirm_ask("I confirm I am authorized to test these targets.")
            if not ok:
                io.tool_error("Ethics disclaimer not accepted. Exiting PentestAider.")
                import sys
                sys.exit(1)

    def cmd_recon(self, args):
        """
        Run reconnaissance tasks on target(s).

        Usage: /recon <target1> [target2 ...]
        """
        targets = args.split()
        if not targets:
            self.io.tool_error("No targets provided for recon.")
            return
        for target in targets:
            if not utils.in_scope(target, self.scope):
                self.io.tool_error(f"Target '{target}' is not in scope.")
                continue
            recon_mgr = ReconManager(self.io, self.allow_exec)
            recon_mgr.basic_recon(target)
            results = recon_mgr.get_results()
            if results:
                self.io.tool_output("==== Recon Summary ====")
                for tool, snippet in results:
                    self.io.tool_output(f"[{tool}]")
                    lines = snippet.splitlines()
                    for line in lines[:5]:
                        self.io.tool_output(line)
                    if len(lines) > 5:
                        self.io.tool_output("... (truncated) ...")

    def cmd_scan(self, args):
        """
        Perform vulnerability assessment on the specified target(s).
        """
        targets = args.split()
        if not targets:
            self.io.tool_error("No targets provided for scan.")
            return
        for target in targets:
            if not utils.in_scope(target, self.scope):
                self.io.tool_error(f"Target '{target}' is not in scope.")
                continue
            vuln_mgr = VulnerabilityManager(self.io, self.allow_exec)
            vuln_mgr.basic_scan(target)
            results = vuln_mgr.get_results()
            if results:
                self.io.tool_output("==== Vulnerability Scan Summary ====")
                for tool, snippet in results:
                    self.io.tool_output(f"[{tool}]")
                    lines = snippet.splitlines()
                    for line in lines[:5]:
                        self.io.tool_output(line)
                    if len(lines) > 5:
                        self.io.tool_output("... (truncated) ...")

    def cmd_osint(self, args):
        """
        Run basic OSINT (whois, DNS, Shodan) on target(s).

        Usage: /osint <target1> [target2 ...]
        """
        targets = args.split()
        if not targets:
            self.io.tool_error("No targets provided for OSINT.")
            return
        for target in targets:
            if not utils.in_scope(target, self.scope):
                self.io.tool_error(f"Target '{target}' is not in scope.")
                continue
            OSINTManager(self.io, self.allow_exec).basic_osint(target)

    def cmd_exploit(self, args):
        """
        Generate or simulate exploit payloads for given target(s).

        Usage:
            /exploit reverse <bash|python|nc> <lhost> <lport>
            /exploit msf <payload_type> <lhost> <lport>
        """
        tokens = args.strip().split()
        if not tokens:
            self.io.tool_error("No exploit command given.")
            return
        mgr = ExploitManager(self.io, self.allow_exec)
        if tokens[0] == "reverse" and len(tokens) == 4:
            _, shell_type, lhost, lport = tokens
            payload = mgr.generate_reverse_shell(shell_type, lhost, lport)
            self.io.tool_output(f"Reverse shell ({shell_type}):\n{payload}")
        elif tokens[0] == "msf" and len(tokens) == 4:
            _, payload_type, lhost, lport = tokens
            mgr.metasploit_payload(payload_type, lhost, lport)
        else:
            self.io.tool_error(
                "Usage: /exploit reverse <bash|python|nc> <lhost> <lport> OR /exploit msf <payload_type> <lhost> <lport>"
            )
            return
        results = mgr.get_results()
        if results:
            self.io.tool_output("==== Exploit Summary ====")
            for tool, snippet in results:
                self.io.tool_output(f"[{tool}]")
                lines = snippet.splitlines()
                for line in lines[:5]:
                    self.io.tool_output(line)
                if len(lines) > 5:
                    self.io.tool_output("... (truncated) ...")

    def cmd_reportgen(self, args):
        """
        Generate a pentest report.
        """
        try:
            ReportManager(self.io).generate_report([])
        except Exception:
            self.io.tool_output("Report generation coming soon. (stub)")

    def cmd_pentest_mode(self, args):
        """
        Toggle between pentest and normal mode (stub).
        """
        self.io.tool_output("Pentest mode is currently enabled. (stub)")

    def cmd_reportgen(self, args):
        """
        Generate a pentest report. (stub)
        """
        self.io.tool_output("Report generation coming soon.")