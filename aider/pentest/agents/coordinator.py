"""
Agent coordinator that manages specialized sub-agents for different pentesting domains.
"""

import asyncio
import logging
from typing import Dict, List, Any, Optional
from datetime import datetime

from ..config import PentestConfig
from ...io import InputOutput


class SpecializedAgent:
    """Base class for specialized pentesting agents."""
    
    def __init__(self, agent_type: str, config: PentestConfig, io: InputOutput):
        self.agent_type = agent_type
        self.config = config
        self.io = io
        self.logger = logging.getLogger(f"agent.{agent_type}")
        self.status = "idle"
        self.current_task = None
    
    async def execute_task(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a specific task assigned to this agent."""
        self.status = "running"
        self.current_task = task
        
        try:
            result = await self._execute_task_impl(task)
            self.status = "completed"
            return result
        except Exception as e:
            self.status = "failed" 
            self.logger.error(f"Task execution failed: {e}")
            raise
        finally:
            self.current_task = None
    
    async def _execute_task_impl(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Implementation-specific task execution - override in subclasses."""
        raise NotImplementedError


class ReconAgent(SpecializedAgent):
    """Reconnaissance agent for information gathering."""
    
    def __init__(self, config: PentestConfig, io: InputOutput):
        super().__init__("recon", config, io)
    
    async def _execute_task_impl(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Execute reconnaissance tasks like port scanning, service enumeration."""
        target = task.get("target")
        scan_type = task.get("scan_type", "standard")
        
        self.logger.info(f"Starting {scan_type} reconnaissance on {target}")
        
        # Simulate reconnaissance activities
        results = {
            "agent": "recon",
            "target": target,
            "scan_type": scan_type,
            "timestamp": datetime.now().isoformat(),
            "findings": []
        }
        
        # Mock findings - in real implementation, would use nmap, masscan, etc.
        if scan_type == "port_scan":
            results["findings"] = [
                {"port": 22, "service": "ssh", "state": "open"},
                {"port": 80, "service": "http", "state": "open"},
                {"port": 443, "service": "https", "state": "open"}
            ]
        elif scan_type == "service_enum":
            results["findings"] = [
                {"service": "ssh", "version": "OpenSSH 7.4", "banner": "SSH-2.0-OpenSSH_7.4"},
                {"service": "http", "version": "Apache 2.4.6", "headers": {"Server": "Apache/2.4.6"}}
            ]
        
        return results


class ExploitAgent(SpecializedAgent):
    """Exploitation agent for vulnerability testing."""
    
    def __init__(self, config: PentestConfig, io: InputOutput):
        super().__init__("exploit", config, io)
    
    async def _execute_task_impl(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Execute exploitation tasks."""
        target = task.get("target") 
        vulnerability = task.get("vulnerability")
        exploit_type = task.get("exploit_type", "safe")
        
        self.logger.info(f"Testing {vulnerability} on {target} (mode: {exploit_type})")
        
        results = {
            "agent": "exploit",
            "target": target,
            "vulnerability": vulnerability,
            "exploit_type": exploit_type,
            "timestamp": datetime.now().isoformat(),
            "success": False,
            "evidence": []
        }
        
        # Mock exploitation results - in real implementation, would use Metasploit, custom exploits
        if exploit_type == "safe":
            results["success"] = True
            results["evidence"] = ["Version banner confirms vulnerability", "Response time indicates injection"]
        
        return results


class ReportingAgent(SpecializedAgent):
    """Reporting agent for documentation and evidence compilation."""
    
    def __init__(self, config: PentestConfig, io: InputOutput):
        super().__init__("reporting", config, io)
    
    async def _execute_task_impl(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Generate reports from assessment findings."""
        findings = task.get("findings", [])
        report_format = task.get("format", "json")
        
        self.logger.info(f"Generating {report_format} report with {len(findings)} findings")
        
        results = {
            "agent": "reporting",
            "format": report_format,
            "timestamp": datetime.now().isoformat(),
            "report_generated": True,
            "summary": {
                "total_findings": len(findings),
                "critical": len([f for f in findings if f.get("severity") == "critical"]),
                "high": len([f for f in findings if f.get("severity") == "high"]),
                "medium": len([f for f in findings if f.get("severity") == "medium"]),
                "low": len([f for f in findings if f.get("severity") == "low"])
            }
        }
        
        return results


class CleanupAgent(SpecializedAgent):
    """Cleanup agent for removing traces and artifacts."""
    
    def __init__(self, config: PentestConfig, io: InputOutput):
        super().__init__("cleanup", config, io)
    
    async def _execute_task_impl(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Clean up assessment artifacts and traces."""
        target = task.get("target")
        cleanup_type = task.get("cleanup_type", "standard")
        
        self.logger.info(f"Performing {cleanup_type} cleanup on {target}")
        
        results = {
            "agent": "cleanup",
            "target": target,
            "cleanup_type": cleanup_type,
            "timestamp": datetime.now().isoformat(),
            "actions_performed": [
                "Removed temporary files",
                "Cleared session artifacts", 
                "Reset target state"
            ]
        }
        
        return results


class AgentCoordinator:
    """Coordinates multiple specialized agents using message bus or reinforcement learning."""
    
    def __init__(self, config: PentestConfig, io: InputOutput):
        self.config = config
        self.io = io
        self.logger = logging.getLogger("agent.coordinator")
        
        # Initialize specialized agents
        self.agents = {
            "recon": ReconAgent(config, io),
            "exploit": ExploitAgent(config, io), 
            "reporting": ReportingAgent(config, io),
            "cleanup": CleanupAgent(config, io)
        }
        
        # Message bus for agent coordination
        self.message_queue = asyncio.Queue()
        self.active_tasks = {}
        
    async def execute_workflow(self, workflow: Dict[str, Any], target: str) -> Dict[str, Any]:
        """Execute a multi-agent workflow."""
        self.logger.info(f"Executing workflow: {workflow.get('name', 'unknown')}")
        
        workflow_results = {
            "workflow": workflow.get("name"),
            "target": target,
            "start_time": datetime.now().isoformat(),
            "phases": []
        }
        
        # Execute workflow phases sequentially
        for phase in workflow.get("phases", []):
            phase_results = await self._execute_phase(phase, target)
            workflow_results["phases"].append(phase_results)
            
            # Check if phase failed and handle accordingly
            if phase_results.get("status") == "failed":
                self.logger.error(f"Phase {phase['name']} failed, aborting workflow")
                workflow_results["status"] = "failed"
                break
        else:
            workflow_results["status"] = "completed"
        
        workflow_results["end_time"] = datetime.now().isoformat()
        return workflow_results
    
    async def _execute_phase(self, phase: Dict[str, Any], target: str) -> Dict[str, Any]:
        """Execute a single phase of the workflow."""
        phase_name = phase.get("name")
        agent_type = phase.get("agent")
        tasks = phase.get("tasks", [])
        
        self.logger.info(f"Executing phase: {phase_name} with agent: {agent_type}")
        
        if agent_type not in self.agents:
            raise ValueError(f"Unknown agent type: {agent_type}")
        
        agent = self.agents[agent_type]
        phase_results = {
            "name": phase_name,
            "agent": agent_type,
            "target": target,
            "start_time": datetime.now().isoformat(),
            "task_results": []
        }
        
        try:
            # Execute all tasks in the phase
            for task in tasks:
                task["target"] = target
                task_result = await agent.execute_task(task)
                phase_results["task_results"].append(task_result)
            
            phase_results["status"] = "completed"
            
        except Exception as e:
            self.logger.error(f"Phase {phase_name} failed: {e}")
            phase_results["status"] = "failed"
            phase_results["error"] = str(e)
        
        phase_results["end_time"] = datetime.now().isoformat()
        return phase_results
    
    async def get_agent_status(self) -> Dict[str, Any]:
        """Get status of all agents."""
        return {
            agent_type: {
                "status": agent.status,
                "current_task": agent.current_task
            }
            for agent_type, agent in self.agents.items()
        }