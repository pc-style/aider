"""
FastAPI REST Server for Pentest AI

Provides comprehensive REST API for the pentest AI system with real-time capabilities.
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
from contextlib import asynccontextmanager

from fastapi import FastAPI, HTTPException, Depends, BackgroundTasks, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field
import uvicorn

from ..core import (
    MultiAgentOrchestrator,
    MCPClient,
    ContainerManager,
    GraphDatabase,
    SafetyGates,
    AuditLogger,
    Target,
    Session,
    Vulnerability,
    Credential,
    EventType,
    LogLevel
)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Security
security = HTTPBearer()

# Global components
orchestrator: Optional[MultiAgentOrchestrator] = None
mcp_client: Optional[MCPClient] = None
container_manager: Optional[ContainerManager] = None
graph_db: Optional[GraphDatabase] = None
safety_gates: Optional[SafetyGates] = None
audit_logger: Optional[AuditLogger] = None

# WebSocket connections
active_connections: List[WebSocket] = []


# Pydantic models for API
class TargetCreate(BaseModel):
    name: str
    type: str = "domain"
    scope: List[str] = ["web"]
    metadata: Optional[Dict[str, Any]] = None


class TargetResponse(BaseModel):
    id: str
    name: str
    type: str
    scope: List[str]
    status: str
    created_at: datetime
    updated_at: datetime
    metadata: Optional[Dict[str, Any]] = None


class ScanRequest(BaseModel):
    target: str
    scope: List[str] = ["web"]
    tools: Optional[List[str]] = None
    workflow_type: str = "comprehensive"
    parameters: Optional[Dict[str, Any]] = None


class ScanResponse(BaseModel):
    workflow_id: str
    status: str
    message: str


class WorkflowStatusResponse(BaseModel):
    workflow_id: str
    status: str
    start_time: datetime
    end_time: Optional[datetime]
    steps_completed: List[str]
    steps_failed: List[str]
    progress: float
    estimated_completion: Optional[datetime]


class ReportRequest(BaseModel):
    workflow_id: str
    format: str = "html"
    include_details: bool = True


class SafetyCheckRequest(BaseModel):
    target: str
    scope: List[str]
    tools: List[str]
    user_id: str
    operation_type: str


class SafetyCheckResponse(BaseModel):
    passed: bool
    checks: List[Dict[str, Any]]
    message: str


class LLMRequest(BaseModel):
    message: str
    provider: Optional[str] = None
    model: Optional[str] = None
    system_prompt: Optional[str] = None
    timeout: Optional[int] = 60


class LLMResponse(BaseModel):
    response: str
    provider: str
    model: str
    tokens_used: Optional[int] = None
    response_time: float


class ContainerInfo(BaseModel):
    id: str
    name: str
    status: str
    image: str
    created: str
    ports: Optional[Dict[str, str]] = None


class SystemStatus(BaseModel):
    status: str
    components: Dict[str, str]
    uptime: float
    version: str


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan manager"""
    global orchestrator, mcp_client, container_manager, graph_db, safety_gates, audit_logger
    
    # Startup
    logger.info("Starting Pentest AI API Server...")
    
    try:
        # Initialize components
        mcp_client = MCPClient()
        graph_db = GraphDatabase()
        safety_gates = SafetyGates()
        audit_logger = AuditLogger()
        container_manager = ContainerManager()
        
        orchestrator = MultiAgentOrchestrator(
            mcp_client=mcp_client,
            graph_db=graph_db,
            safety_gates=safety_gates,
            audit_logger=audit_logger
        )
        
        logger.info("All components initialized successfully")
        
        # Log system startup
        audit_logger.log_event(
            event_type=EventType.SYSTEM_START,
            level=LogLevel.INFO,
            user_id="system",
            message="API server started",
            details={"version": "0.1.0"}
        )
        
        yield
        
    except Exception as e:
        logger.error(f"Failed to initialize components: {e}")
        raise
    
    finally:
        # Shutdown
        logger.info("Shutting down Pentest AI API Server...")
        
        # Close connections
        for connection in active_connections:
            try:
                await connection.close()
            except:
                pass
        
        # Log system shutdown
        if audit_logger:
            audit_logger.log_event(
                event_type=EventType.SYSTEM_SHUTDOWN,
                level=LogLevel.INFO,
                user_id="system",
                message="API server shutdown",
                details={}
            )


# Create FastAPI app
app = FastAPI(
    title="Pentest AI API",
    description="AI-powered penetration testing platform API",
    version="0.1.0",
    lifespan=lifespan
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure appropriately for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# Dependency for authentication
async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Simple token-based authentication"""
    # In production, implement proper JWT validation
    token = credentials.credentials
    if token != "demo-token":  # Replace with proper validation
        raise HTTPException(status_code=401, detail="Invalid token")
    return {"user_id": "demo_user"}


# WebSocket manager
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def send_personal_message(self, message: str, websocket: WebSocket):
        await websocket.send_text(message)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            try:
                await connection.send_text(message)
            except:
                pass


manager = ConnectionManager()


# Health check endpoint
@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow(),
        "version": "0.1.0"
    }


# System status endpoint
@app.get("/status", response_model=SystemStatus)
async def get_system_status():
    """Get system status and component health"""
    components = {}
    
    # Check component health
    try:
        if graph_db:
            components["graph_database"] = "healthy"
        else:
            components["graph_database"] = "unavailable"
    except:
        components["graph_database"] = "error"
    
    try:
        if container_manager:
            components["container_manager"] = "healthy"
        else:
            components["container_manager"] = "unavailable"
    except:
        components["container_manager"] = "error"
    
    try:
        if mcp_client:
            providers = await mcp_client.get_available_providers()
            components["llm_providers"] = f"healthy ({len(providers)} providers)"
        else:
            components["llm_providers"] = "unavailable"
    except:
        components["llm_providers"] = "error"
    
    return SystemStatus(
        status="operational",
        components=components,
        uptime=0.0,  # Calculate actual uptime
        version="0.1.0"
    )


# Target management endpoints
@app.post("/targets", response_model=TargetResponse)
async def create_target(
    target: TargetCreate,
    current_user: Dict = Depends(get_current_user)
):
    """Create a new target"""
    try:
        # Create target
        new_target = Target(
            id=f"target_{datetime.utcnow().timestamp()}",
            name=target.name,
            type=target.type,
            scope=target.scope,
            status="active",
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow(),
            metadata=target.metadata or {}
        )
        
        success = await graph_db.create_target(new_target)
        if not success:
            raise HTTPException(status_code=500, detail="Failed to create target")
        
        # Log event
        audit_logger.log_event(
            event_type=EventType.TARGET_CREATE,
            level=LogLevel.INFO,
            user_id=current_user["user_id"],
            message=f"Target created: {target.name}",
            target_id=new_target.id,
            details=target.dict()
        )
        
        return TargetResponse(**new_target.__dict__)
    
    except Exception as e:
        logger.error(f"Failed to create target: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/targets", response_model=List[TargetResponse])
async def list_targets(
    query: Optional[str] = None,
    status: Optional[str] = None,
    limit: int = 50,
    offset: int = 0,
    current_user: Dict = Depends(get_current_user)
):
    """List targets with optional filtering"""
    try:
        filters = {}
        if status:
            filters["status"] = status
        
        targets = await graph_db.search_targets(query or "", filters)
        return [TargetResponse(**target.__dict__) for target in targets[offset:offset + limit]]
    
    except Exception as e:
        logger.error(f"Failed to list targets: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/targets/{target_id}", response_model=TargetResponse)
async def get_target(
    target_id: str,
    current_user: Dict = Depends(get_current_user)
):
    """Get a specific target"""
    try:
        target = await graph_db.get_target(target_id)
        if not target:
            raise HTTPException(status_code=404, detail="Target not found")
        
        return TargetResponse(**target.__dict__)
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get target: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# Scan endpoints
@app.post("/scans", response_model=ScanResponse)
async def create_scan(
    scan_request: ScanRequest,
    background_tasks: BackgroundTasks,
    current_user: Dict = Depends(get_current_user)
):
    """Create and start a new scan"""
    try:
        # Safety checks
        safety_checks = await safety_gates.comprehensive_safety_check(
            target=scan_request.target,
            scope=scan_request.scope,
            tools=scan_request.tools or ["nmap", "nikto"],
            user_id=current_user["user_id"],
            operation_type="scan"
        )
        
        failed_checks = [check for check in safety_checks if not check.passed]
        if failed_checks:
            raise HTTPException(
                status_code=403,
                detail=f"Safety checks failed: {[check.message for check in failed_checks]}"
            )
        
        # Create workflow
        workflow_id = await orchestrator.create_workflow(
            target=scan_request.target,
            scope=scan_request.scope,
            workflow_type=scan_request.workflow_type,
            parameters=scan_request.parameters
        )
        
        # Start execution in background
        background_tasks.add_task(execute_workflow_background, workflow_id)
        
        # Log event
        audit_logger.log_event(
            event_type=EventType.WORKFLOW_CREATE,
            level=LogLevel.INFO,
            user_id=current_user["user_id"],
            workflow_id=workflow_id,
            message=f"Scan started for target: {scan_request.target}",
            details=scan_request.dict()
        )
        
        return ScanResponse(
            workflow_id=workflow_id,
            status="started",
            message="Scan started successfully"
        )
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to create scan: {e}")
        raise HTTPException(status_code=500, detail=str(e))


async def execute_workflow_background(workflow_id: str):
    """Execute workflow in background"""
    try:
        result = await orchestrator.execute_workflow(workflow_id)
        
        # Broadcast completion
        await manager.broadcast(f"Workflow {workflow_id} completed with status: {result.status.value}")
        
    except Exception as e:
        logger.error(f"Background workflow execution failed: {e}")
        await manager.broadcast(f"Workflow {workflow_id} failed: {str(e)}")


@app.get("/scans/{workflow_id}/status", response_model=WorkflowStatusResponse)
async def get_scan_status(
    workflow_id: str,
    current_user: Dict = Depends(get_current_user)
):
    """Get scan status and progress"""
    try:
        result = await orchestrator.get_workflow_status(workflow_id)
        if not result:
            raise HTTPException(status_code=404, detail="Workflow not found")
        
        # Calculate progress
        total_steps = len(result.steps_completed) + len(result.steps_failed)
        progress = len(result.steps_completed) / total_steps if total_steps > 0 else 0.0
        
        # Estimate completion time
        estimated_completion = None
        if result.status.value == "running" and result.start_time:
            elapsed = datetime.utcnow() - result.start_time
            if progress > 0:
                total_estimated = elapsed / progress
                estimated_completion = result.start_time + total_estimated
        
        return WorkflowStatusResponse(
            workflow_id=workflow_id,
            status=result.status.value,
            start_time=result.start_time,
            end_time=result.end_time,
            steps_completed=result.steps_completed,
            steps_failed=result.steps_failed,
            progress=progress,
            estimated_completion=estimated_completion
        )
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get scan status: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.delete("/scans/{workflow_id}")
async def cancel_scan(
    workflow_id: str,
    current_user: Dict = Depends(get_current_user)
):
    """Cancel a running scan"""
    try:
        success = await orchestrator.cancel_workflow(workflow_id)
        if not success:
            raise HTTPException(status_code=404, detail="Workflow not found or already completed")
        
        # Log event
        audit_logger.log_event(
            event_type=EventType.WORKFLOW_CANCEL,
            level=LogLevel.INFO,
            user_id=current_user["user_id"],
            workflow_id=workflow_id,
            message=f"Scan cancelled: {workflow_id}"
        )
        
        return {"message": "Scan cancelled successfully"}
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to cancel scan: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# Report endpoints
@app.post("/reports")
async def generate_report(
    report_request: ReportRequest,
    current_user: Dict = Depends(get_current_user)
):
    """Generate a report for a workflow"""
    try:
        # Get workflow data
        workflow_data = await graph_db.get_workflow(report_request.workflow_id)
        if not workflow_data:
            raise HTTPException(status_code=404, detail="Workflow not found")
        
        # Generate report (simplified for demo)
        report_content = f"""
# Pentest Report

## Workflow Information
- ID: {report_request.workflow_id}
- Target: {workflow_data.get('target', 'Unknown')}
- Status: {workflow_data.get('status', 'Unknown')}
- Format: {report_request.format}

## Summary
This is a generated report for the pentest workflow.

## Details
{workflow_data.get('results', 'No results available')}
"""
        
        # Log event
        audit_logger.log_event(
            event_type=EventType.DATA_EXPORT,
            level=LogLevel.INFO,
            user_id=current_user["user_id"],
            workflow_id=report_request.workflow_id,
            message=f"Report generated: {report_request.format}",
            details=report_request.dict()
        )
        
        return {
            "report_id": f"report_{datetime.utcnow().timestamp()}",
            "format": report_request.format,
            "content": report_content,
            "generated_at": datetime.utcnow()
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to generate report: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# Safety endpoints
@app.post("/safety/check", response_model=SafetyCheckResponse)
async def perform_safety_check(
    check_request: SafetyCheckRequest,
    current_user: Dict = Depends(get_current_user)
):
    """Perform comprehensive safety checks"""
    try:
        safety_checks = await safety_gates.comprehensive_safety_check(
            target=check_request.target,
            scope=check_request.scope,
            tools=check_request.tools,
            user_id=check_request.user_id,
            operation_type=check_request.operation_type
        )
        
        passed = all(check.passed for check in safety_checks)
        
        return SafetyCheckResponse(
            passed=passed,
            checks=[check.__dict__ for check in safety_checks],
            message="Safety checks completed"
        )
    
    except Exception as e:
        logger.error(f"Failed to perform safety check: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# LLM endpoints
@app.post("/llm/chat", response_model=LLMResponse)
async def chat_with_llm(
    request: LLMRequest,
    current_user: Dict = Depends(get_current_user)
):
    """Send a message to an LLM"""
    try:
        start_time = datetime.utcnow()
        
        response = await mcp_client.send_message(
            message=request.message,
            provider=request.provider,
            model=request.model,
            system_prompt=request.system_prompt,
            timeout=request.timeout
        )
        
        response_time = (datetime.utcnow() - start_time).total_seconds()
        
        # Log event
        audit_logger.log_event(
            event_type=EventType.DATA_ACCESS,
            level=LogLevel.INFO,
            user_id=current_user["user_id"],
            message=f"LLM chat: {request.provider or 'default'}",
            details={
                "provider": request.provider,
                "model": request.model,
                "response_time": response_time
            }
        )
        
        return LLMResponse(
            response=response,
            provider=request.provider or "default",
            model=request.model or "default",
            response_time=response_time
        )
    
    except Exception as e:
        logger.error(f"Failed to chat with LLM: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/llm/providers")
async def get_llm_providers(current_user: Dict = Depends(get_current_user)):
    """Get available LLM providers"""
    try:
        providers = await mcp_client.get_available_providers()
        return {"providers": providers}
    
    except Exception as e:
        logger.error(f"Failed to get LLM providers: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# Container endpoints
@app.get("/containers", response_model=List[ContainerInfo])
async def list_containers(current_user: Dict = Depends(get_current_user)):
    """List running containers"""
    try:
        containers = await container_manager.list_containers()
        return [
            ContainerInfo(
                id=container["id"],
                name=container["name"],
                status=container["status"],
                image=container["image"],
                created="",  # Add actual creation time
                ports=None
            )
            for container in containers
        ]
    
    except Exception as e:
        logger.error(f"Failed to list containers: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.delete("/containers/{container_id}")
async def stop_container(
    container_id: str,
    current_user: Dict = Depends(get_current_user)
):
    """Stop a container"""
    try:
        success = await container_manager.stop_container(container_id)
        if not success:
            raise HTTPException(status_code=404, detail="Container not found")
        
        return {"message": "Container stopped successfully"}
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to stop container: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# Audit endpoints
@app.get("/audit/events")
async def get_audit_events(
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
    event_type: Optional[str] = None,
    user_id: Optional[str] = None,
    limit: int = 100,
    offset: int = 0,
    current_user: Dict = Depends(get_current_user)
):
    """Get audit events with filtering"""
    try:
        events = await audit_logger.get_events(
            start_time=start_time,
            end_time=end_time,
            limit=limit,
            offset=offset
        )
        
        return {
            "events": [event.__dict__ for event in events],
            "total": len(events),
            "limit": limit,
            "offset": offset
        }
    
    except Exception as e:
        logger.error(f"Failed to get audit events: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/audit/statistics")
async def get_audit_statistics(
    start_time: Optional[datetime] = None,
    end_time: Optional[datetime] = None,
    current_user: Dict = Depends(get_current_user)
):
    """Get audit statistics"""
    try:
        stats = await audit_logger.get_statistics(
            start_time=start_time,
            end_time=end_time
        )
        
        return stats
    
    except Exception as e:
        logger.error(f"Failed to get audit statistics: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# WebSocket endpoint for real-time updates
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket endpoint for real-time updates"""
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            # Echo back for now, could implement command processing
            await manager.send_personal_message(f"Message: {data}", websocket)
    except WebSocketDisconnect:
        manager.disconnect(websocket)


# Tool-specific endpoints
@app.post("/tools/nmap")
async def run_nmap_scan(
    target: str,
    scan_type: str = "basic",
    ports: Optional[str] = None,
    current_user: Dict = Depends(get_current_user)
):
    """Run nmap scan"""
    try:
        result = await container_manager.run_nmap_scan(
            target=target,
            scan_type=scan_type,
            ports=ports
        )
        
        return {
            "target": target,
            "scan_type": scan_type,
            "status": result.status.value,
            "exit_code": result.exit_code,
            "output": result.stdout,
            "error": result.error
        }
    
    except Exception as e:
        logger.error(f"Failed to run nmap scan: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/tools/sqlmap")
async def run_sqlmap_scan(
    target: str,
    level: int = 1,
    risk: int = 1,
    current_user: Dict = Depends(get_current_user)
):
    """Run sqlmap scan"""
    try:
        result = await container_manager.run_sqlmap_scan(
            target=target,
            level=level,
            risk=risk
        )
        
        return {
            "target": target,
            "level": level,
            "risk": risk,
            "status": result.status.value,
            "exit_code": result.exit_code,
            "output": result.stdout,
            "error": result.error
        }
    
    except Exception as e:
        logger.error(f"Failed to run sqlmap scan: {e}")
        raise HTTPException(status_code=500, detail=str(e))


if __name__ == "__main__":
    uvicorn.run(
        "pentest_ai.api.server:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )