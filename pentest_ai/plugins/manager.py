"""
Plugin Management System for Pentest AI

Provides a comprehensive plugin architecture for extending the pentest AI system
with custom tools, workflows, and integrations.
"""

import os
import sys
import json
import yaml
import logging
import asyncio
import importlib
import importlib.util
from pathlib import Path
from typing import Dict, List, Optional, Any, Callable, Type
from dataclasses import dataclass, field
from abc import ABC, abstractmethod
import inspect
import hashlib
import zipfile
import tempfile
import shutil
from collections import defaultdict

from ..core import (
    GraphDatabase,
    AuditLogger,
    EventType,
    LogLevel
)

logger = logging.getLogger(__name__)


@dataclass
class PluginMetadata:
    """Plugin metadata information"""
    name: str
    version: str
    description: str
    author: str
    license: str
    homepage: Optional[str] = None
    repository: Optional[str] = None
    dependencies: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    category: str = "general"
    entry_point: str = "main"
    config_schema: Optional[Dict[str, Any]] = None
    permissions: List[str] = field(default_factory=list)
    min_version: str = "0.1.0"
    max_version: Optional[str] = None


@dataclass
class PluginConfig:
    """Plugin configuration"""
    enabled: bool = True
    settings: Dict[str, Any] = field(default_factory=dict)
    schedule: Optional[str] = None  # Cron expression for scheduled execution


class PluginBase(ABC):
    """Base class for all plugins"""
    
    def __init__(self, metadata: PluginMetadata, config: PluginConfig):
        self.metadata = metadata
        self.config = config
        self.logger = logging.getLogger(f"plugin.{metadata.name}")
    
    @abstractmethod
    async def initialize(self) -> bool:
        """Initialize the plugin"""
        pass
    
    @abstractmethod
    async def cleanup(self) -> bool:
        """Cleanup plugin resources"""
        pass
    
    @abstractmethod
    async def execute(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the plugin with given context"""
        pass


class ToolPlugin(PluginBase):
    """Base class for tool plugins"""
    
    @abstractmethod
    async def run_scan(self, target: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Run a scan with the tool"""
        pass
    
    @abstractmethod
    async def parse_results(self, output: str) -> List[Dict[str, Any]]:
        """Parse tool output into structured results"""
        pass


class WorkflowPlugin(PluginBase):
    """Base class for workflow plugins"""
    
    @abstractmethod
    async def get_workflow_steps(self) -> List[Dict[str, Any]]:
        """Get workflow steps definition"""
        pass
    
    @abstractmethod
    async def execute_step(self, step: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a workflow step"""
        pass


class IntegrationPlugin(PluginBase):
    """Base class for integration plugins"""
    
    @abstractmethod
    async def connect(self, credentials: Dict[str, Any]) -> bool:
        """Connect to external service"""
        pass
    
    @abstractmethod
    async def sync_data(self, data: Dict[str, Any]) -> bool:
        """Sync data with external service"""
        pass


class PluginManager:
    """Main plugin management system"""
    
    def __init__(
        self,
        graph_db: GraphDatabase,
        audit_logger: AuditLogger,
        plugins_dir: str = "plugins",
        marketplace_url: Optional[str] = None
    ):
        self.graph_db = graph_db
        self.audit_logger = audit_logger
        self.plugins_dir = Path(plugins_dir)
        self.marketplace_url = marketplace_url
        
        # Plugin registry
        self.plugins: Dict[str, PluginBase] = {}
        self.plugin_metadata: Dict[str, PluginMetadata] = {}
        self.plugin_configs: Dict[str, PluginConfig] = {}
        
        # Plugin categories
        self.categories = {
            "tools": [],
            "workflows": [],
            "integrations": [],
            "reporting": [],
            "security": [],
            "utilities": []
        }
        
        # Plugin hooks
        self.hooks: Dict[str, List[Callable]] = defaultdict(list)
        
        # Security
        self.sandbox_enabled = True
        self.allowed_permissions = {
            "file_read": ["config", "logs", "reports"],
            "file_write": ["output", "temp"],
            "network_access": ["api", "sync"],
            "system_access": ["metrics", "processes"]
        }
        
        # Create plugins directory
        self.plugins_dir.mkdir(exist_ok=True)
        
        # Load plugin configurations
        self._load_configs()
    
    def _load_configs(self):
        """Load plugin configurations"""
        config_file = self.plugins_dir / "config.json"
        if config_file.exists():
            try:
                with open(config_file, 'r') as f:
                    configs = json.load(f)
                
                for plugin_name, config_data in configs.items():
                    self.plugin_configs[plugin_name] = PluginConfig(**config_data)
                
                logger.info(f"Loaded {len(configs)} plugin configurations")
            
            except Exception as e:
                logger.error(f"Failed to load plugin configurations: {e}")
    
    def _save_configs(self):
        """Save plugin configurations"""
        config_file = self.plugins_dir / "config.json"
        try:
            configs = {
                name: {
                    "enabled": config.enabled,
                    "settings": config.settings,
                    "schedule": config.schedule
                }
                for name, config in self.plugin_configs.items()
            }
            
            with open(config_file, 'w') as f:
                json.dump(configs, f, indent=2)
            
            logger.info("Plugin configurations saved")
        
        except Exception as e:
            logger.error(f"Failed to save plugin configurations: {e}")
    
    async def discover_plugins(self) -> List[PluginMetadata]:
        """Discover available plugins"""
        discovered = []
        
        try:
            for plugin_dir in self.plugins_dir.iterdir():
                if not plugin_dir.is_dir():
                    continue
                
                # Check for plugin manifest
                manifest_file = plugin_dir / "manifest.json"
                if not manifest_file.exists():
                    continue
                
                try:
                    with open(manifest_file, 'r') as f:
                        manifest_data = json.load(f)
                    
                    metadata = PluginMetadata(**manifest_data)
                    discovered.append(metadata)
                    
                    logger.info(f"Discovered plugin: {metadata.name} v{metadata.version}")
                
                except Exception as e:
                    logger.error(f"Failed to load plugin manifest {manifest_file}: {e}")
        
        except Exception as e:
            logger.error(f"Failed to discover plugins: {e}")
        
        return discovered
    
    async def load_plugin(self, plugin_name: str) -> bool:
        """Load a specific plugin"""
        try:
            plugin_dir = self.plugins_dir / plugin_name
            if not plugin_dir.exists():
                logger.error(f"Plugin directory not found: {plugin_dir}")
                return False
            
            # Load manifest
            manifest_file = plugin_dir / "manifest.json"
            if not manifest_file.exists():
                logger.error(f"Plugin manifest not found: {manifest_file}")
                return False
            
            with open(manifest_file, 'r') as f:
                manifest_data = json.load(f)
            
            metadata = PluginMetadata(**manifest_data)
            
            # Check version compatibility
            if not self._check_version_compatibility(metadata):
                logger.error(f"Plugin {plugin_name} version incompatible")
                return False
            
            # Check dependencies
            if not await self._check_dependencies(metadata.dependencies):
                logger.error(f"Plugin {plugin_name} dependencies not met")
                return False
            
            # Load plugin module
            entry_file = plugin_dir / f"{metadata.entry_point}.py"
            if not entry_file.exists():
                logger.error(f"Plugin entry point not found: {entry_file}")
                return False
            
            # Import plugin module
            spec = importlib.util.spec_from_file_location(
                f"plugins.{plugin_name}",
                entry_file
            )
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            # Find plugin class
            plugin_class = self._find_plugin_class(module, metadata)
            if not plugin_class:
                logger.error(f"Plugin class not found in {plugin_name}")
                return False
            
            # Get or create configuration
            config = self.plugin_configs.get(plugin_name, PluginConfig())
            
            # Create plugin instance
            plugin = plugin_class(metadata, config)
            
            # Initialize plugin
            if not await plugin.initialize():
                logger.error(f"Failed to initialize plugin {plugin_name}")
                return False
            
            # Register plugin
            self.plugins[plugin_name] = plugin
            self.plugin_metadata[plugin_name] = metadata
            self.plugin_configs[plugin_name] = config
            
            # Categorize plugin
            self._categorize_plugin(plugin_name, metadata)
            
            # Log plugin loading
            await self.audit_logger.log_event(
                event_type=EventType.PLUGIN_LOAD,
                level=LogLevel.INFO,
                user_id="system",
                message=f"Plugin loaded: {plugin_name}",
                details={
                    "plugin_name": plugin_name,
                    "version": metadata.version,
                    "category": metadata.category
                }
            )
            
            logger.info(f"Plugin loaded successfully: {plugin_name}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to load plugin {plugin_name}: {e}")
            return False
    
    def _check_version_compatibility(self, metadata: PluginMetadata) -> bool:
        """Check if plugin version is compatible"""
        try:
            # Simple version check - in production, use proper semver comparison
            current_version = "0.1.0"  # Get from system
            
            if metadata.min_version and metadata.min_version > current_version:
                return False
            
            if metadata.max_version and metadata.max_version < current_version:
                return False
            
            return True
        
        except Exception as e:
            logger.error(f"Version compatibility check failed: {e}")
            return False
    
    async def _check_dependencies(self, dependencies: List[str]) -> bool:
        """Check if plugin dependencies are available"""
        try:
            for dep in dependencies:
                # Check if dependency is installed
                try:
                    importlib.import_module(dep)
                except ImportError:
                    logger.warning(f"Dependency not available: {dep}")
                    return False
            
            return True
        
        except Exception as e:
            logger.error(f"Dependency check failed: {e}")
            return False
    
    def _find_plugin_class(self, module: Any, metadata: PluginMetadata) -> Optional[Type[PluginBase]]:
        """Find the plugin class in the module"""
        try:
            # Look for classes that inherit from PluginBase
            for name, obj in inspect.getmembers(module):
                if (inspect.isclass(obj) and 
                    issubclass(obj, PluginBase) and 
                    obj != PluginBase):
                    return obj
            
            return None
        
        except Exception as e:
            logger.error(f"Failed to find plugin class: {e}")
            return None
    
    def _categorize_plugin(self, plugin_name: str, metadata: PluginMetadata):
        """Categorize plugin based on metadata"""
        category = metadata.category.lower()
        if category in self.categories:
            self.categories[category].append(plugin_name)
        else:
            self.categories["utilities"].append(plugin_name)
    
    async def unload_plugin(self, plugin_name: str) -> bool:
        """Unload a plugin"""
        try:
            if plugin_name not in self.plugins:
                logger.warning(f"Plugin not loaded: {plugin_name}")
                return False
            
            plugin = self.plugins[plugin_name]
            
            # Cleanup plugin
            if not await plugin.cleanup():
                logger.warning(f"Plugin cleanup failed: {plugin_name}")
            
            # Remove from registry
            del self.plugins[plugin_name]
            del self.plugin_metadata[plugin_name]
            
            # Remove from categories
            for category_plugins in self.categories.values():
                if plugin_name in category_plugins:
                    category_plugins.remove(plugin_name)
            
            # Log plugin unloading
            await self.audit_logger.log_event(
                event_type=EventType.PLUGIN_UNLOAD,
                level=LogLevel.INFO,
                user_id="system",
                message=f"Plugin unloaded: {plugin_name}"
            )
            
            logger.info(f"Plugin unloaded: {plugin_name}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to unload plugin {plugin_name}: {e}")
            return False
    
    async def enable_plugin(self, plugin_name: str) -> bool:
        """Enable a plugin"""
        try:
            if plugin_name not in self.plugin_configs:
                logger.error(f"Plugin not found: {plugin_name}")
                return False
            
            config = self.plugin_configs[plugin_name]
            config.enabled = True
            
            # Load plugin if not already loaded
            if plugin_name not in self.plugins:
                await self.load_plugin(plugin_name)
            
            self._save_configs()
            
            logger.info(f"Plugin enabled: {plugin_name}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to enable plugin {plugin_name}: {e}")
            return False
    
    async def disable_plugin(self, plugin_name: str) -> bool:
        """Disable a plugin"""
        try:
            if plugin_name not in self.plugin_configs:
                logger.error(f"Plugin not found: {plugin_name}")
                return False
            
            config = self.plugin_configs[plugin_name]
            config.enabled = False
            
            # Unload plugin if loaded
            if plugin_name in self.plugins:
                await self.unload_plugin(plugin_name)
            
            self._save_configs()
            
            logger.info(f"Plugin disabled: {plugin_name}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to disable plugin {plugin_name}: {e}")
            return False
    
    async def configure_plugin(self, plugin_name: str, settings: Dict[str, Any]) -> bool:
        """Configure plugin settings"""
        try:
            if plugin_name not in self.plugin_configs:
                logger.error(f"Plugin not found: {plugin_name}")
                return False
            
            config = self.plugin_configs[plugin_name]
            config.settings.update(settings)
            
            # Update plugin instance if loaded
            if plugin_name in self.plugins:
                plugin = self.plugins[plugin_name]
                plugin.config = config
            
            self._save_configs()
            
            logger.info(f"Plugin configured: {plugin_name}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to configure plugin {plugin_name}: {e}")
            return False
    
    async def execute_plugin(self, plugin_name: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a plugin"""
        try:
            if plugin_name not in self.plugins:
                logger.error(f"Plugin not loaded: {plugin_name}")
                return {"error": "Plugin not loaded"}
            
            plugin = self.plugins[plugin_name]
            
            if not plugin.config.enabled:
                logger.error(f"Plugin disabled: {plugin_name}")
                return {"error": "Plugin disabled"}
            
            # Check permissions
            if not self._check_permissions(plugin.metadata.permissions, context):
                logger.error(f"Permission denied for plugin: {plugin_name}")
                return {"error": "Permission denied"}
            
            # Execute plugin
            result = await plugin.execute(context)
            
            # Log execution
            await self.audit_logger.log_event(
                event_type=EventType.PLUGIN_EXECUTE,
                level=LogLevel.INFO,
                user_id=context.get("user_id", "system"),
                message=f"Plugin executed: {plugin_name}",
                details={
                    "plugin_name": plugin_name,
                    "context": context,
                    "result": result
                }
            )
            
            return result
        
        except Exception as e:
            logger.error(f"Failed to execute plugin {plugin_name}: {e}")
            return {"error": str(e)}
    
    def _check_permissions(self, permissions: List[str], context: Dict[str, Any]) -> bool:
        """Check if plugin has required permissions"""
        try:
            if not self.sandbox_enabled:
                return True  # Skip permission checks if sandbox disabled
            
            for permission in permissions:
                if not self._has_permission(permission, context):
                    return False
            
            return True
        
        except Exception as e:
            logger.error(f"Permission check failed: {e}")
            return False
    
    def _has_permission(self, permission: str, context: Dict[str, Any]) -> bool:
        """Check if plugin has specific permission"""
        try:
            # Simple permission checking - in production, implement proper RBAC
            if permission in self.allowed_permissions:
                return True
            
            return False
        
        except Exception as e:
            logger.error(f"Permission check failed: {e}")
            return False
    
    async def install_plugin(self, plugin_path: str) -> bool:
        """Install a plugin from file or URL"""
        try:
            # Create temporary directory
            with tempfile.TemporaryDirectory() as temp_dir:
                temp_path = Path(temp_dir)
                
                # Extract plugin if it's a zip file
                if plugin_path.endswith('.zip'):
                    with zipfile.ZipFile(plugin_path, 'r') as zip_ref:
                        zip_ref.extractall(temp_path)
                else:
                    # Copy plugin directory
                    source_path = Path(plugin_path)
                    if source_path.is_dir():
                        shutil.copytree(source_path, temp_path / source_path.name)
                    else:
                        logger.error(f"Invalid plugin path: {plugin_path}")
                        return False
                
                # Find plugin directory
                plugin_dirs = [d for d in temp_path.iterdir() if d.is_dir()]
                if not plugin_dirs:
                    logger.error("No plugin directory found")
                    return False
                
                plugin_dir = plugin_dirs[0]
                
                # Validate plugin
                if not await self._validate_plugin(plugin_dir):
                    logger.error("Plugin validation failed")
                    return False
                
                # Load manifest
                manifest_file = plugin_dir / "manifest.json"
                with open(manifest_file, 'r') as f:
                    manifest_data = json.load(f)
                
                metadata = PluginMetadata(**manifest_data)
                
                # Check if plugin already exists
                if metadata.name in self.plugin_metadata:
                    logger.warning(f"Plugin already exists: {metadata.name}")
                    return False
                
                # Install plugin
                install_path = self.plugins_dir / metadata.name
                shutil.copytree(plugin_dir, install_path)
                
                # Load plugin
                await self.load_plugin(metadata.name)
                
                logger.info(f"Plugin installed: {metadata.name}")
                return True
        
        except Exception as e:
            logger.error(f"Failed to install plugin: {e}")
            return False
    
    async def _validate_plugin(self, plugin_dir: Path) -> bool:
        """Validate plugin structure and content"""
        try:
            # Check for manifest
            manifest_file = plugin_dir / "manifest.json"
            if not manifest_file.exists():
                logger.error("Plugin manifest not found")
                return False
            
            # Validate manifest
            with open(manifest_file, 'r') as f:
                manifest_data = json.load(f)
            
            required_fields = ["name", "version", "description", "author"]
            for field in required_fields:
                if field not in manifest_data:
                    logger.error(f"Required field missing: {field}")
                    return False
            
            # Check for entry point
            entry_point = manifest_data.get("entry_point", "main")
            entry_file = plugin_dir / f"{entry_point}.py"
            if not entry_file.exists():
                logger.error(f"Entry point not found: {entry_file}")
                return False
            
            # Validate entry point
            if not await self._validate_entry_point(entry_file):
                logger.error("Entry point validation failed")
                return False
            
            return True
        
        except Exception as e:
            logger.error(f"Plugin validation failed: {e}")
            return False
    
    async def _validate_entry_point(self, entry_file: Path) -> bool:
        """Validate plugin entry point"""
        try:
            # Basic syntax check
            with open(entry_file, 'r') as f:
                content = f.read()
            
            # Check for basic plugin structure
            if "class" not in content or "PluginBase" not in content:
                logger.error("Invalid plugin structure")
                return False
            
            return True
        
        except Exception as e:
            logger.error(f"Entry point validation failed: {e}")
            return False
    
    async def uninstall_plugin(self, plugin_name: str) -> bool:
        """Uninstall a plugin"""
        try:
            # Unload plugin if loaded
            if plugin_name in self.plugins:
                await self.unload_plugin(plugin_name)
            
            # Remove plugin directory
            plugin_dir = self.plugins_dir / plugin_name
            if plugin_dir.exists():
                shutil.rmtree(plugin_dir)
            
            # Remove configuration
            if plugin_name in self.plugin_configs:
                del self.plugin_configs[plugin_name]
                self._save_configs()
            
            logger.info(f"Plugin uninstalled: {plugin_name}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to uninstall plugin {plugin_name}: {e}")
            return False
    
    async def get_plugin_info(self, plugin_name: str) -> Optional[Dict[str, Any]]:
        """Get plugin information"""
        try:
            if plugin_name not in self.plugin_metadata:
                return None
            
            metadata = self.plugin_metadata[plugin_name]
            config = self.plugin_configs.get(plugin_name, PluginConfig())
            
            return {
                "name": metadata.name,
                "version": metadata.version,
                "description": metadata.description,
                "author": metadata.author,
                "license": metadata.license,
                "homepage": metadata.homepage,
                "repository": metadata.repository,
                "dependencies": metadata.dependencies,
                "tags": metadata.tags,
                "category": metadata.category,
                "enabled": config.enabled,
                "settings": config.settings,
                "schedule": config.schedule,
                "loaded": plugin_name in self.plugins
            }
        
        except Exception as e:
            logger.error(f"Failed to get plugin info: {e}")
            return None
    
    async def list_plugins(self, category: Optional[str] = None) -> List[Dict[str, Any]]:
        """List all plugins"""
        try:
            plugins = []
            
            for plugin_name in self.plugin_metadata:
                if category and plugin_name not in self.categories.get(category, []):
                    continue
                
                info = await self.get_plugin_info(plugin_name)
                if info:
                    plugins.append(info)
            
            return plugins
        
        except Exception as e:
            logger.error(f"Failed to list plugins: {e}")
            return []
    
    async def get_plugin_categories(self) -> Dict[str, List[str]]:
        """Get plugin categories"""
        return self.categories.copy()
    
    async def register_hook(self, hook_name: str, callback: Callable):
        """Register a plugin hook"""
        try:
            self.hooks[hook_name].append(callback)
            logger.info(f"Hook registered: {hook_name}")
        
        except Exception as e:
            logger.error(f"Failed to register hook: {e}")
    
    async def call_hook(self, hook_name: str, *args, **kwargs) -> List[Any]:
        """Call registered hooks"""
        try:
            results = []
            
            for callback in self.hooks[hook_name]:
                try:
                    if asyncio.iscoroutinefunction(callback):
                        result = await callback(*args, **kwargs)
                    else:
                        result = callback(*args, **kwargs)
                    
                    results.append(result)
                
                except Exception as e:
                    logger.error(f"Hook execution failed: {e}")
            
            return results
        
        except Exception as e:
            logger.error(f"Failed to call hooks: {e}")
            return []
    
    async def get_marketplace_plugins(self) -> List[Dict[str, Any]]:
        """Get plugins from marketplace"""
        try:
            if not self.marketplace_url:
                return []
            
            # This would fetch from the marketplace API
            # For now, return mock data
            return [
                {
                    "name": "advanced_nmap",
                    "version": "1.0.0",
                    "description": "Advanced Nmap scanning plugin",
                    "author": "Security Team",
                    "category": "tools",
                    "downloads": 150,
                    "rating": 4.5
                },
                {
                    "name": "custom_workflow",
                    "version": "0.5.0",
                    "description": "Custom pentest workflow",
                    "author": "Pentest Expert",
                    "category": "workflows",
                    "downloads": 75,
                    "rating": 4.2
                }
            ]
        
        except Exception as e:
            logger.error(f"Failed to get marketplace plugins: {e}")
            return []
    
    async def update_plugin(self, plugin_name: str) -> bool:
        """Update a plugin"""
        try:
            # This would check for updates and download them
            # For now, just log the request
            logger.info(f"Plugin update requested: {plugin_name}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to update plugin: {e}")
            return False
    
    async def backup_plugins(self, backup_path: str) -> bool:
        """Backup all plugins"""
        try:
            backup_dir = Path(backup_path)
            backup_dir.mkdir(parents=True, exist_ok=True)
            
            # Copy plugins directory
            plugins_backup = backup_dir / "plugins"
            if self.plugins_dir.exists():
                shutil.copytree(self.plugins_dir, plugins_backup, dirs_exist_ok=True)
            
            # Backup configurations
            config_backup = backup_dir / "plugin_configs.json"
            with open(config_backup, 'w') as f:
                json.dump({
                    name: {
                        "enabled": config.enabled,
                        "settings": config.settings,
                        "schedule": config.schedule
                    }
                    for name, config in self.plugin_configs.items()
                }, f, indent=2)
            
            logger.info(f"Plugins backed up to: {backup_path}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to backup plugins: {e}")
            return False
    
    async def restore_plugins(self, backup_path: str) -> bool:
        """Restore plugins from backup"""
        try:
            backup_dir = Path(backup_path)
            
            # Restore plugins directory
            plugins_backup = backup_dir / "plugins"
            if plugins_backup.exists():
                if self.plugins_dir.exists():
                    shutil.rmtree(self.plugins_dir)
                shutil.copytree(plugins_backup, self.plugins_dir)
            
            # Restore configurations
            config_backup = backup_dir / "plugin_configs.json"
            if config_backup.exists():
                with open(config_backup, 'r') as f:
                    configs = json.load(f)
                
                for plugin_name, config_data in configs.items():
                    self.plugin_configs[plugin_name] = PluginConfig(**config_data)
                
                self._save_configs()
            
            logger.info(f"Plugins restored from: {backup_path}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to restore plugins: {e}")
            return False