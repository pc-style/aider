"""
Report Generator for Pentest AI

Generates comprehensive reports in multiple formats (HTML, PDF, Markdown, JSON)
with customizable templates and styling.
"""

import os
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
from pathlib import Path
import asyncio

from jinja2 import Environment, FileSystemLoader, Template
import markdown
from weasyprint import HTML, CSS
import yaml

from ..core import (
    GraphDatabase,
    Target,
    Session,
    Vulnerability,
    Credential,
    EventType,
    LogLevel
)

logger = logging.getLogger(__name__)


class ReportTemplate:
    """Report template configuration"""
    
    def __init__(self, name: str, format: str, template_path: str, css_path: Optional[str] = None):
        self.name = name
        self.format = format
        self.template_path = template_path
        self.css_path = css_path


class ReportData:
    """Structured data for report generation"""
    
    def __init__(self):
        self.workflow_id: str = ""
        self.target: Optional[Target] = None
        self.sessions: List[Session] = []
        self.vulnerabilities: List[Vulnerability] = []
        self.credentials: List[Credential] = []
        self.scan_results: Dict[str, Any] = {}
        self.execution_summary: Dict[str, Any] = {}
        self.risk_assessment: Dict[str, Any] = {}
        self.recommendations: List[str] = []
        self.metadata: Dict[str, Any] = {}


class ReportGenerator:
    """Main report generator class"""
    
    def __init__(self, graph_db: GraphDatabase, templates_dir: str = "templates"):
        self.graph_db = graph_db
        self.templates_dir = Path(templates_dir)
        self.templates_dir.mkdir(exist_ok=True)
        
        # Initialize Jinja2 environment
        self.jinja_env = Environment(
            loader=FileSystemLoader(str(self.templates_dir)),
            autoescape=True,
            trim_blocks=True,
            lstrip_blocks=True
        )
        
        # Register custom filters
        self.jinja_env.filters['format_datetime'] = self._format_datetime
        self.jinja_env.filters['format_duration'] = self._format_duration
        self.jinja_env.filters['severity_color'] = self._severity_color
        self.jinja_env.filters['risk_level'] = self._risk_level
        
        # Initialize default templates
        self._init_default_templates()
    
    def _init_default_templates(self):
        """Initialize default report templates"""
        self.templates = {
            "html": ReportTemplate(
                name="default_html",
                format="html",
                template_path="html_report.html",
                css_path="html_report.css"
            ),
            "pdf": ReportTemplate(
                name="default_pdf",
                format="pdf",
                template_path="pdf_report.html",
                css_path="pdf_report.css"
            ),
            "markdown": ReportTemplate(
                name="default_markdown",
                format="markdown",
                template_path="markdown_report.md"
            ),
            "json": ReportTemplate(
                name="default_json",
                format="json",
                template_path="json_report.json"
            )
        }
        
        # Create default templates if they don't exist
        self._create_default_templates()
    
    def _create_default_templates(self):
        """Create default template files"""
        
        # HTML template
        html_template = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pentest Report - {{ target.name }}</title>
    <link rel="stylesheet" href="{{ css_path }}">
</head>
<body>
    <div class="container">
        <header class="report-header">
            <h1>Penetration Testing Report</h1>
            <div class="report-meta">
                <p><strong>Target:</strong> {{ target.name }}</p>
                <p><strong>Date:</strong> {{ execution_summary.start_time | format_datetime }}</p>
                <p><strong>Duration:</strong> {{ execution_summary.duration | format_duration }}</p>
                <p><strong>Risk Level:</strong> <span class="risk-{{ risk_assessment.overall_level | risk_level }}">{{ risk_assessment.overall_level }}</span></p>
            </div>
        </header>

        <section class="executive-summary">
            <h2>Executive Summary</h2>
            <div class="summary-stats">
                <div class="stat-card">
                    <h3>Vulnerabilities Found</h3>
                    <p class="stat-number">{{ vulnerabilities | length }}</p>
                </div>
                <div class="stat-card">
                    <h3>Critical Issues</h3>
                    <p class="stat-number critical">{{ vulnerabilities | selectattr('severity', 'equalto', 'critical') | list | length }}</p>
                </div>
                <div class="stat-card">
                    <h3>High Risk</h3>
                    <p class="stat-number high">{{ vulnerabilities | selectattr('severity', 'equalto', 'high') | list | length }}</p>
                </div>
                <div class="stat-card">
                    <h3>Medium Risk</h3>
                    <p class="stat-number medium">{{ vulnerabilities | selectattr('severity', 'equalto', 'medium') | list | length }}</p>
                </div>
            </div>
        </section>

        <section class="methodology">
            <h2>Methodology</h2>
            <p>This penetration test was conducted using the following methodology:</p>
            <ul>
                {% for step in execution_summary.steps %}
                <li>{{ step.name }} - {{ step.status }}</li>
                {% endfor %}
            </ul>
        </section>

        <section class="findings">
            <h2>Findings</h2>
            {% for vuln in vulnerabilities %}
            <div class="vulnerability">
                <h3 class="severity-{{ vuln.severity | severity_color }}">{{ vuln.title }}</h3>
                <div class="vuln-meta">
                    <span class="severity {{ vuln.severity | severity_color }}">{{ vuln.severity | upper }}</span>
                    <span class="cvss">CVSS: {{ vuln.cvss_score }}</span>
                    {% if vuln.cve_id %}
                    <span class="cve">CVE: {{ vuln.cve_id }}</span>
                    {% endif %}
                </div>
                <div class="vuln-description">
                    <h4>Description</h4>
                    <p>{{ vuln.description }}</p>
                </div>
                {% if vuln.proof_of_concept %}
                <div class="vuln-poc">
                    <h4>Proof of Concept</h4>
                    <pre><code>{{ vuln.proof_of_concept }}</code></pre>
                </div>
                {% endif %}
                <div class="vuln-recommendation">
                    <h4>Recommendation</h4>
                    <p>{{ vuln.recommendation }}</p>
                </div>
            </div>
            {% endfor %}
        </section>

        <section class="credentials">
            <h2>Credentials Discovered</h2>
            {% if credentials %}
            <table class="credentials-table">
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Username</th>
                        <th>Password</th>
                        <th>Source</th>
                    </tr>
                </thead>
                <tbody>
                    {% for cred in credentials %}
                    <tr>
                        <td>{{ cred.type }}</td>
                        <td>{{ cred.username }}</td>
                        <td>{{ cred.password }}</td>
                        <td>{{ cred.source }}</td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
            {% else %}
            <p>No credentials were discovered during this assessment.</p>
            {% endif %}
        </section>

        <section class="recommendations">
            <h2>Recommendations</h2>
            <ol>
                {% for rec in recommendations %}
                <li>{{ rec }}</li>
                {% endfor %}
            </ol>
        </section>

        <section class="appendix">
            <h2>Appendix</h2>
            <h3>Scan Results</h3>
            <pre><code>{{ scan_results | tojson(indent=2) }}</code></pre>
        </section>
    </div>
</body>
</html>
"""
        
        # CSS template
        css_template = """
/* Pentest Report Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.6;
    color: #333;
    background-color: #f5f5f5;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    background: white;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
}

.report-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 2rem;
    text-align: center;
}

.report-header h1 {
    font-size: 2.5rem;
    margin-bottom: 1rem;
}

.report-meta {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
}

.report-meta p {
    background: rgba(255,255,255,0.1);
    padding: 0.5rem;
    border-radius: 5px;
}

section {
    padding: 2rem;
    border-bottom: 1px solid #eee;
}

section h2 {
    color: #2c3e50;
    margin-bottom: 1rem;
    font-size: 1.8rem;
}

.summary-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 1rem;
    margin: 1rem 0;
}

.stat-card {
    background: #f8f9fa;
    padding: 1rem;
    border-radius: 8px;
    text-align: center;
    border-left: 4px solid #007bff;
}

.stat-card h3 {
    font-size: 0.9rem;
    color: #6c757d;
    margin-bottom: 0.5rem;
}

.stat-number {
    font-size: 2rem;
    font-weight: bold;
    color: #007bff;
}

.stat-number.critical { color: #dc3545; }
.stat-number.high { color: #fd7e14; }
.stat-number.medium { color: #ffc107; }

.vulnerability {
    background: #f8f9fa;
    margin: 1rem 0;
    padding: 1.5rem;
    border-radius: 8px;
    border-left: 4px solid #007bff;
}

.vulnerability h3 {
    color: #2c3e50;
    margin-bottom: 0.5rem;
}

.vuln-meta {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
}

.severity, .cvss, .cve {
    padding: 0.25rem 0.5rem;
    border-radius: 3px;
    font-size: 0.8rem;
    font-weight: bold;
}

.severity.critical { background: #dc3545; color: white; }
.severity.high { background: #fd7e14; color: white; }
.severity.medium { background: #ffc107; color: black; }
.severity.low { background: #28a745; color: white; }

.cvss, .cve {
    background: #6c757d;
    color: white;
}

.vuln-description, .vuln-poc, .vuln-recommendation {
    margin: 1rem 0;
}

.vuln-description h4, .vuln-poc h4, .vuln-recommendation h4 {
    color: #495057;
    margin-bottom: 0.5rem;
}

pre {
    background: #f8f9fa;
    padding: 1rem;
    border-radius: 5px;
    overflow-x: auto;
    border: 1px solid #dee2e6;
}

.credentials-table {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
}

.credentials-table th,
.credentials-table td {
    padding: 0.75rem;
    text-align: left;
    border-bottom: 1px solid #dee2e6;
}

.credentials-table th {
    background: #f8f9fa;
    font-weight: bold;
}

.recommendations ol {
    margin-left: 1.5rem;
}

.recommendations li {
    margin: 0.5rem 0;
}

.risk-critical { color: #dc3545; }
.risk-high { color: #fd7e14; }
.risk-medium { color: #ffc107; }
.risk-low { color: #28a745; }

@media print {
    body { background: white; }
    .container { box-shadow: none; }
    .report-header { break-inside: avoid; }
    .vulnerability { break-inside: avoid; }
}
"""
        
        # Markdown template
        markdown_template = """# Penetration Testing Report

## Target Information
- **Target:** {{ target.name }}
- **Date:** {{ execution_summary.start_time | format_datetime }}
- **Duration:** {{ execution_summary.duration | format_duration }}
- **Risk Level:** {{ risk_assessment.overall_level }}

## Executive Summary

This penetration test was conducted against {{ target.name }} on {{ execution_summary.start_time | format_datetime }}.

### Key Statistics
- **Total Vulnerabilities:** {{ vulnerabilities | length }}
- **Critical Issues:** {{ vulnerabilities | selectattr('severity', 'equalto', 'critical') | list | length }}
- **High Risk Issues:** {{ vulnerabilities | selectattr('severity', 'equalto', 'high') | list | length }}
- **Medium Risk Issues:** {{ vulnerabilities | selectattr('severity', 'equalto', 'medium') | list | length }}

## Methodology

The following steps were performed during this assessment:

{% for step in execution_summary.steps %}
- {{ step.name }} - {{ step.status }}
{% endfor %}

## Findings

{% for vuln in vulnerabilities %}
### {{ vuln.title }}

**Severity:** {{ vuln.severity | upper }}  
**CVSS Score:** {{ vuln.cvss_score }}
{% if vuln.cve_id %}
**CVE ID:** {{ vuln.cve_id }}
{% endif %}

#### Description
{{ vuln.description }}

{% if vuln.proof_of_concept %}
#### Proof of Concept
```
{{ vuln.proof_of_concept }}
```
{% endif %}

#### Recommendation
{{ vuln.recommendation }}

---
{% endfor %}

## Credentials Discovered

{% if credentials %}
| Type | Username | Password | Source |
|------|----------|----------|--------|
{% for cred in credentials %}
| {{ cred.type }} | {{ cred.username }} | {{ cred.password }} | {{ cred.source }} |
{% endfor %}
{% else %}
No credentials were discovered during this assessment.
{% endif %}

## Recommendations

{% for rec in recommendations %}
{{ loop.index }}. {{ rec }}
{% endfor %}

## Appendix

### Scan Results
```json
{{ scan_results | tojson(indent=2) }}
```
"""
        
        # Create template files
        templates = {
            "html_report.html": html_template,
            "html_report.css": css_template,
            "markdown_report.md": markdown_template
        }
        
        for filename, content in templates.items():
            template_path = self.templates_dir / filename
            if not template_path.exists():
                template_path.write_text(content)
                logger.info(f"Created default template: {filename}")
    
    def _format_datetime(self, dt: datetime) -> str:
        """Format datetime for display"""
        if isinstance(dt, str):
            try:
                dt = datetime.fromisoformat(dt.replace('Z', '+00:00'))
            except:
                return dt
        return dt.strftime("%Y-%m-%d %H:%M:%S UTC")
    
    def _format_duration(self, duration: Union[str, timedelta]) -> str:
        """Format duration for display"""
        if isinstance(duration, str):
            try:
                # Parse ISO duration
                duration = timedelta(seconds=float(duration))
            except:
                return duration
        
        total_seconds = int(duration.total_seconds())
        hours = total_seconds // 3600
        minutes = (total_seconds % 3600) // 60
        seconds = total_seconds % 60
        
        if hours > 0:
            return f"{hours}h {minutes}m {seconds}s"
        elif minutes > 0:
            return f"{minutes}m {seconds}s"
        else:
            return f"{seconds}s"
    
    def _severity_color(self, severity: str) -> str:
        """Get CSS class for severity level"""
        severity_map = {
            "critical": "critical",
            "high": "high", 
            "medium": "medium",
            "low": "low"
        }
        return severity_map.get(severity.lower(), "medium")
    
    def _risk_level(self, level: str) -> str:
        """Get CSS class for risk level"""
        level_map = {
            "critical": "critical",
            "high": "high",
            "medium": "medium", 
            "low": "low"
        }
        return level_map.get(level.lower(), "medium")
    
    async def generate_report(
        self,
        workflow_id: str,
        format: str = "html",
        template_name: Optional[str] = None,
        include_details: bool = True,
        output_path: Optional[str] = None
    ) -> Dict[str, Any]:
        """Generate a comprehensive report"""
        
        try:
            # Collect report data
            report_data = await self._collect_report_data(workflow_id)
            
            # Get template
            template = self._get_template(format, template_name)
            
            # Generate report content
            if format == "json":
                content = self._generate_json_report(report_data)
            else:
                content = await self._generate_templated_report(report_data, template)
            
            # Save to file if output path specified
            if output_path:
                output_file = Path(output_path)
                output_file.parent.mkdir(parents=True, exist_ok=True)
                
                if format == "pdf":
                    # Convert HTML to PDF
                    html_content = await self._generate_templated_report(report_data, self.templates["html"])
                    HTML(string=html_content).write_pdf(output_file)
                else:
                    # Write content directly
                    if format == "json":
                        output_file.write_text(json.dumps(content, indent=2))
                    else:
                        output_file.write_text(content)
                
                logger.info(f"Report saved to: {output_file}")
            
            return {
                "workflow_id": workflow_id,
                "format": format,
                "template": template.name,
                "content": content,
                "generated_at": datetime.utcnow().isoformat(),
                "file_path": str(output_path) if output_path else None
            }
        
        except Exception as e:
            logger.error(f"Failed to generate report: {e}")
            raise
    
    async def _collect_report_data(self, workflow_id: str) -> ReportData:
        """Collect all data needed for report generation"""
        
        data = ReportData()
        data.workflow_id = workflow_id
        
        # Get workflow information
        workflow = await self.graph_db.get_workflow(workflow_id)
        if workflow:
            data.metadata = workflow
        
        # Get target information
        if workflow and "target_id" in workflow:
            data.target = await self.graph_db.get_target(workflow["target_id"])
        
        # Get sessions
        data.sessions = await self.graph_db.get_sessions_by_workflow(workflow_id)
        
        # Get vulnerabilities
        data.vulnerabilities = await self.graph_db.get_vulnerabilities_by_workflow(workflow_id)
        
        # Get credentials
        data.credentials = await self.graph_db.get_credentials_by_workflow(workflow_id)
        
        # Calculate execution summary
        data.execution_summary = await self._calculate_execution_summary(workflow_id)
        
        # Calculate risk assessment
        data.risk_assessment = await self._calculate_risk_assessment(data.vulnerabilities)
        
        # Generate recommendations
        data.recommendations = await self._generate_recommendations(data.vulnerabilities)
        
        # Get scan results
        data.scan_results = await self._get_scan_results(workflow_id)
        
        return data
    
    async def _calculate_execution_summary(self, workflow_id: str) -> Dict[str, Any]:
        """Calculate execution summary from workflow data"""
        
        # This would typically come from the orchestrator
        # For now, return a basic structure
        return {
            "start_time": datetime.utcnow() - timedelta(hours=2),
            "end_time": datetime.utcnow(),
            "duration": timedelta(hours=2),
            "steps": [
                {"name": "Reconnaissance", "status": "completed"},
                {"name": "Vulnerability Scan", "status": "completed"},
                {"name": "Exploitation", "status": "completed"},
                {"name": "Post-Exploitation", "status": "completed"}
            ],
            "total_steps": 4,
            "completed_steps": 4,
            "failed_steps": 0
        }
    
    async def _calculate_risk_assessment(self, vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
        """Calculate overall risk assessment"""
        
        if not vulnerabilities:
            return {"overall_level": "low", "score": 0.0}
        
        # Calculate weighted risk score
        severity_weights = {
            "critical": 10.0,
            "high": 7.0,
            "medium": 4.0,
            "low": 1.0
        }
        
        total_score = 0.0
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        
        for vuln in vulnerabilities:
            weight = severity_weights.get(vuln.severity.lower(), 1.0)
            total_score += weight
            severity_counts[vuln.severity.lower()] += 1
        
        # Determine overall risk level
        if severity_counts["critical"] > 0:
            overall_level = "critical"
        elif severity_counts["high"] > 0:
            overall_level = "high"
        elif severity_counts["medium"] > 0:
            overall_level = "medium"
        else:
            overall_level = "low"
        
        return {
            "overall_level": overall_level,
            "score": total_score,
            "severity_breakdown": severity_counts,
            "total_vulnerabilities": len(vulnerabilities)
        }
    
    async def _generate_recommendations(self, vulnerabilities: List[Vulnerability]) -> List[str]:
        """Generate recommendations based on vulnerabilities"""
        
        recommendations = []
        
        # Critical vulnerabilities
        critical_vulns = [v for v in vulnerabilities if v.severity.lower() == "critical"]
        if critical_vulns:
            recommendations.append("Immediately address all critical vulnerabilities to prevent potential system compromise.")
        
        # High vulnerabilities
        high_vulns = [v for v in vulnerabilities if v.severity.lower() == "high"]
        if high_vulns:
            recommendations.append("Prioritize fixing high-severity vulnerabilities within 30 days.")
        
        # Medium vulnerabilities
        medium_vulns = [v for v in vulnerabilities if v.severity.lower() == "medium"]
        if medium_vulns:
            recommendations.append("Address medium-severity vulnerabilities within 90 days.")
        
        # General recommendations
        if vulnerabilities:
            recommendations.extend([
                "Implement regular security assessments and penetration testing.",
                "Establish a vulnerability management program with defined SLAs.",
                "Provide security awareness training to all staff members.",
                "Implement proper access controls and least privilege principles.",
                "Regularly update and patch all systems and applications."
            ])
        
        return recommendations
    
    async def _get_scan_results(self, workflow_id: str) -> Dict[str, Any]:
        """Get detailed scan results"""
        
        # This would typically come from the container manager or orchestrator
        # For now, return a basic structure
        return {
            "nmap_scan": {
                "status": "completed",
                "open_ports": [22, 80, 443, 8080],
                "services": {
                    "22": "SSH",
                    "80": "HTTP",
                    "443": "HTTPS",
                    "8080": "HTTP-Proxy"
                }
            },
            "web_scan": {
                "status": "completed",
                "vulnerabilities_found": 5,
                "endpoints_tested": 150
            },
            "database_scan": {
                "status": "completed",
                "databases_found": 2,
                "weak_passwords": 1
            }
        }
    
    def _get_template(self, format: str, template_name: Optional[str] = None) -> ReportTemplate:
        """Get the appropriate template for the format"""
        
        if template_name:
            # Look for custom template
            template_path = self.templates_dir / f"{template_name}.{format}"
            if template_path.exists():
                return ReportTemplate(
                    name=template_name,
                    format=format,
                    template_path=str(template_path)
                )
        
        # Return default template for format
        if format in self.templates:
            return self.templates[format]
        
        raise ValueError(f"Unsupported report format: {format}")
    
    async def _generate_templated_report(self, data: ReportData, template: ReportTemplate) -> str:
        """Generate report using Jinja2 template"""
        
        # Convert data to template context
        context = {
            "workflow_id": data.workflow_id,
            "target": data.target,
            "sessions": data.sessions,
            "vulnerabilities": data.vulnerabilities,
            "credentials": data.credentials,
            "scan_results": data.scan_results,
            "execution_summary": data.execution_summary,
            "risk_assessment": data.risk_assessment,
            "recommendations": data.recommendations,
            "metadata": data.metadata,
            "generated_at": datetime.utcnow()
        }
        
        # Load and render template
        template_file = self.templates_dir / template.template_path
        if not template_file.exists():
            raise FileNotFoundError(f"Template not found: {template_file}")
        
        jinja_template = self.jinja_env.get_template(template.template_path)
        return jinja_template.render(**context)
    
    def _generate_json_report(self, data: ReportData) -> Dict[str, Any]:
        """Generate JSON report"""
        
        return {
            "workflow_id": data.workflow_id,
            "target": data.target.__dict__ if data.target else None,
            "sessions": [session.__dict__ for session in data.sessions],
            "vulnerabilities": [vuln.__dict__ for vuln in data.vulnerabilities],
            "credentials": [cred.__dict__ for cred in data.credentials],
            "scan_results": data.scan_results,
            "execution_summary": data.execution_summary,
            "risk_assessment": data.risk_assessment,
            "recommendations": data.recommendations,
            "metadata": data.metadata,
            "generated_at": datetime.utcnow().isoformat()
        }
    
    async def list_templates(self) -> List[Dict[str, str]]:
        """List available report templates"""
        
        templates = []
        
        # Add default templates
        for format_name, template in self.templates.items():
            templates.append({
                "name": template.name,
                "format": template.format,
                "type": "default"
            })
        
        # Add custom templates
        for template_file in self.templates_dir.glob("*.*"):
            if template_file.suffix in [".html", ".md", ".json"]:
                templates.append({
                    "name": template_file.stem,
                    "format": template_file.suffix[1:],
                    "type": "custom"
                })
        
        return templates
    
    async def create_custom_template(
        self,
        name: str,
        format: str,
        content: str,
        css_content: Optional[str] = None
    ) -> bool:
        """Create a custom report template"""
        
        try:
            # Save template file
            template_file = self.templates_dir / f"{name}.{format}"
            template_file.write_text(content)
            
            # Save CSS file if provided
            if css_content and format == "html":
                css_file = self.templates_dir / f"{name}.css"
                css_file.write_text(css_content)
            
            logger.info(f"Created custom template: {name}.{format}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to create custom template: {e}")
            return False