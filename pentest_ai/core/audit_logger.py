"""
Audit Logger for Pentest AI

Implements immutable audit logging for comprehensive tracking
of all pentest operations and security events.
"""

import asyncio
import logging
import json
import os
import hashlib
import hmac
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from enum import Enum
import sqlite3
import threading
from pathlib import Path
import aiofiles
import aiofiles.os


class LogLevel(Enum):
    """Log levels for audit events"""
    DEBUG = "debug"
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


class EventType(Enum):
    """Types of audit events"""
    # Authentication events
    LOGIN = "login"
    LOGOUT = "logout"
    AUTH_FAILURE = "auth_failure"
    
    # Session events
    SESSION_START = "session_start"
    SESSION_END = "session_end"
    SESSION_CREATE = "session_create"
    SESSION_DELETE = "session_delete"
    
    # Target events
    TARGET_CREATE = "target_create"
    TARGET_UPDATE = "target_update"
    TARGET_DELETE = "target_delete"
    TARGET_SCAN = "target_scan"
    
    # Workflow events
    WORKFLOW_CREATE = "workflow_create"
    WORKFLOW_START = "workflow_start"
    WORKFLOW_COMPLETE = "workflow_complete"
    WORKFLOW_FAIL = "workflow_fail"
    WORKFLOW_CANCEL = "workflow_cancel"
    
    # Tool events
    TOOL_EXECUTE = "tool_execute"
    TOOL_SUCCESS = "tool_success"
    TOOL_FAILURE = "tool_failure"
    
    # Security events
    SAFETY_CHECK = "safety_check"
    CONSENT_VERIFY = "consent_verify"
    CONSENT_DENY = "consent_deny"
    RATE_LIMIT = "rate_limit"
    BLOCKED_OPERATION = "blocked_operation"
    
    # Data events
    DATA_ACCESS = "data_access"
    DATA_EXPORT = "data_export"
    DATA_DELETE = "data_delete"
    
    # System events
    SYSTEM_START = "system_start"
    SYSTEM_SHUTDOWN = "system_shutdown"
    CONFIG_CHANGE = "config_change"
    
    # Agent events
    AGENT_REGISTER = "agent_register"
    AGENT_UNREGISTER = "agent_unregister"
    AGENT_ERROR = "agent_error"


@dataclass
class AuditEvent:
    """An audit event"""
    id: str
    timestamp: datetime
    event_type: EventType
    level: LogLevel
    user_id: str
    session_id: Optional[str]
    target_id: Optional[str]
    workflow_id: Optional[str]
    message: str
    details: Dict[str, Any]
    source_ip: Optional[str]
    user_agent: Optional[str]
    hash: str


class AuditLogger:
    """
    Immutable audit logger for pentest operations
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.logger = logging.getLogger(__name__)
        
        # Database configuration
        self.db_path = self.config.get("db_path", "audit_log.db")
        self.log_dir = self.config.get("log_dir", "logs")
        self.retention_days = self.config.get("retention_days", 365)
        
        # Security configuration
        self.secret_key = self.config.get("secret_key") or os.getenv("AUDIT_SECRET_KEY", "default-secret")
        self.hash_algorithm = self.config.get("hash_algorithm", "sha256")
        
        # Thread safety
        self.lock = threading.Lock()
        
        # Initialize storage
        self._initialize_storage()
        
        # Start background tasks
        self._start_background_tasks()
    
    def _initialize_storage(self):
        """Initialize audit storage"""
        try:
            # Create log directory
            Path(self.log_dir).mkdir(parents=True, exist_ok=True)
            
            # Initialize SQLite database
            self._init_database()
            
            # Create initial system event
            self._log_system_event("Audit logger initialized")
            
            self.logger.info("Audit logger initialized successfully")
        
        except Exception as e:
            self.logger.error(f"Failed to initialize audit logger: {e}")
            raise
    
    def _init_database(self):
        """Initialize SQLite database for audit events"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # Create audit events table
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS audit_events (
                        id TEXT PRIMARY KEY,
                        timestamp TEXT NOT NULL,
                        event_type TEXT NOT NULL,
                        level TEXT NOT NULL,
                        user_id TEXT NOT NULL,
                        session_id TEXT,
                        target_id TEXT,
                        workflow_id TEXT,
                        message TEXT NOT NULL,
                        details TEXT NOT NULL,
                        source_ip TEXT,
                        user_agent TEXT,
                        hash TEXT NOT NULL,
                        created_at TEXT DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # Create indexes
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_timestamp ON audit_events(timestamp)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_event_type ON audit_events(event_type)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_user_id ON audit_events(user_id)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_id ON audit_events(session_id)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_target_id ON audit_events(target_id)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_workflow_id ON audit_events(workflow_id)")
                
                # Create hash verification table
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS audit_hashes (
                        id TEXT PRIMARY KEY,
                        event_hash TEXT NOT NULL,
                        chain_hash TEXT NOT NULL,
                        timestamp TEXT NOT NULL
                    )
                """)
                
                conn.commit()
        
        except Exception as e:
            self.logger.error(f"Failed to initialize database: {e}")
            raise
    
    def _start_background_tasks(self):
        """Start background maintenance tasks"""
        # In a real implementation, this would start async tasks
        # For now, we'll just log that it's ready
        self.logger.info("Background tasks ready")
    
    def _generate_event_id(self) -> str:
        """Generate a unique event ID"""
        timestamp = datetime.utcnow().isoformat()
        random_component = os.urandom(8).hex()
        return f"{timestamp}_{random_component}"
    
    def _calculate_event_hash(self, event_data: Dict[str, Any]) -> str:
        """Calculate hash for event data"""
        # Create a deterministic string representation
        event_string = json.dumps(event_data, sort_keys=True, default=str)
        
        # Calculate HMAC
        if self.hash_algorithm == "sha256":
            return hmac.new(
                self.secret_key.encode(),
                event_string.encode(),
                hashlib.sha256
            ).hexdigest()
        else:
            return hashlib.md5(event_string.encode()).hexdigest()
    
    def _log_system_event(self, message: str, level: LogLevel = LogLevel.INFO):
        """Log a system event"""
        self.log_event(
            event_type=EventType.SYSTEM_START,
            level=level,
            user_id="system",
            message=message,
            details={"component": "audit_logger"}
        )
    
    def log_event(
        self,
        event_type: EventType,
        level: LogLevel,
        user_id: str,
        message: str,
        details: Optional[Dict[str, Any]] = None,
        session_id: Optional[str] = None,
        target_id: Optional[str] = None,
        workflow_id: Optional[str] = None,
        source_ip: Optional[str] = None,
        user_agent: Optional[str] = None
    ) -> str:
        """
        Log an audit event
        
        Args:
            event_type: Type of event
            level: Log level
            user_id: User ID
            message: Event message
            details: Additional event details
            session_id: Session ID
            target_id: Target ID
            workflow_id: Workflow ID
            source_ip: Source IP address
            user_agent: User agent string
        
        Returns:
            Event ID
        """
        
        try:
            with self.lock:
                # Generate event ID
                event_id = self._generate_event_id()
                timestamp = datetime.utcnow()
                
                # Create event data
                event_data = {
                    "id": event_id,
                    "timestamp": timestamp.isoformat(),
                    "event_type": event_type.value,
                    "level": level.value,
                    "user_id": user_id,
                    "session_id": session_id,
                    "target_id": target_id,
                    "workflow_id": workflow_id,
                    "message": message,
                    "details": details or {},
                    "source_ip": source_ip,
                    "user_agent": user_agent
                }
                
                # Calculate hash
                event_hash = self._calculate_event_hash(event_data)
                event_data["hash"] = event_hash
                
                # Create audit event
                audit_event = AuditEvent(
                    id=event_id,
                    timestamp=timestamp,
                    event_type=event_type,
                    level=level,
                    user_id=user_id,
                    session_id=session_id,
                    target_id=target_id,
                    workflow_id=workflow_id,
                    message=message,
                    details=details or {},
                    source_ip=source_ip,
                    user_agent=user_agent,
                    hash=event_hash
                )
                
                # Store event
                self._store_event(audit_event)
                
                # Log to file
                self._write_to_file(audit_event)
                
                self.logger.debug(f"Logged audit event: {event_id} ({event_type.value})")
                return event_id
        
        except Exception as e:
            self.logger.error(f"Failed to log audit event: {e}")
            # Try to log the failure itself
            try:
                self._log_system_event(f"Audit logging failed: {e}", LogLevel.ERROR)
            except:
                pass
            raise
    
    def _store_event(self, event: AuditEvent):
        """Store event in database"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                cursor.execute("""
                    INSERT INTO audit_events (
                        id, timestamp, event_type, level, user_id, session_id,
                        target_id, workflow_id, message, details, source_ip,
                        user_agent, hash
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    event.id,
                    event.timestamp.isoformat(),
                    event.event_type.value,
                    event.level.value,
                    event.user_id,
                    event.session_id,
                    event.target_id,
                    event.workflow_id,
                    event.message,
                    json.dumps(event.details),
                    event.source_ip,
                    event.user_agent,
                    event.hash
                ))
                
                conn.commit()
        
        except Exception as e:
            self.logger.error(f"Failed to store event in database: {e}")
            raise
    
    def _write_to_file(self, event: AuditEvent):
        """Write event to log file"""
        try:
            # Create daily log file
            date_str = event.timestamp.strftime("%Y-%m-%d")
            log_file = Path(self.log_dir) / f"audit_{date_str}.log"
            
            # Format log entry
            log_entry = {
                "timestamp": event.timestamp.isoformat(),
                "event_id": event.id,
                "event_type": event.event_type.value,
                "level": event.level.value,
                "user_id": event.user_id,
                "message": event.message,
                "details": event.details,
                "hash": event.hash
            }
            
            # Append to file
            with open(log_file, 'a') as f:
                f.write(json.dumps(log_entry) + '\n')
        
        except Exception as e:
            self.logger.error(f"Failed to write event to file: {e}")
            # Don't raise - file logging is secondary to database logging
    
    async def get_events(
        self,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        event_types: Optional[List[EventType]] = None,
        user_id: Optional[str] = None,
        session_id: Optional[str] = None,
        target_id: Optional[str] = None,
        workflow_id: Optional[str] = None,
        level: Optional[LogLevel] = None,
        limit: int = 100,
        offset: int = 0
    ) -> List[AuditEvent]:
        """
        Retrieve audit events with filters
        
        Args:
            start_time: Start time filter
            end_time: End time filter
            event_types: Event types filter
            user_id: User ID filter
            session_id: Session ID filter
            target_id: Target ID filter
            workflow_id: Workflow ID filter
            level: Log level filter
            limit: Maximum number of events
            offset: Offset for pagination
        
        Returns:
            List of audit events
        """
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # Build query
                query = "SELECT * FROM audit_events WHERE 1=1"
                params = []
                
                if start_time:
                    query += " AND timestamp >= ?"
                    params.append(start_time.isoformat())
                
                if end_time:
                    query += " AND timestamp <= ?"
                    params.append(end_time.isoformat())
                
                if event_types:
                    placeholders = ','.join(['?' for _ in event_types])
                    query += f" AND event_type IN ({placeholders})"
                    params.extend([et.value for et in event_types])
                
                if user_id:
                    query += " AND user_id = ?"
                    params.append(user_id)
                
                if session_id:
                    query += " AND session_id = ?"
                    params.append(session_id)
                
                if target_id:
                    query += " AND target_id = ?"
                    params.append(target_id)
                
                if workflow_id:
                    query += " AND workflow_id = ?"
                    params.append(workflow_id)
                
                if level:
                    query += " AND level = ?"
                    params.append(level.value)
                
                query += " ORDER BY timestamp DESC LIMIT ? OFFSET ?"
                params.extend([limit, offset])
                
                # Execute query
                cursor.execute(query, params)
                rows = cursor.fetchall()
                
                # Convert to AuditEvent objects
                events = []
                for row in rows:
                    event = AuditEvent(
                        id=row[0],
                        timestamp=datetime.fromisoformat(row[1]),
                        event_type=EventType(row[2]),
                        level=LogLevel(row[3]),
                        user_id=row[4],
                        session_id=row[5],
                        target_id=row[6],
                        workflow_id=row[7],
                        message=row[8],
                        details=json.loads(row[9]),
                        source_ip=row[10],
                        user_agent=row[11],
                        hash=row[12]
                    )
                    events.append(event)
                
                return events
        
        except Exception as e:
            self.logger.error(f"Failed to retrieve audit events: {e}")
            return []
    
    async def get_event(self, event_id: str) -> Optional[AuditEvent]:
        """Get a specific audit event by ID"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                cursor.execute("SELECT * FROM audit_events WHERE id = ?", (event_id,))
                row = cursor.fetchone()
                
                if row:
                    return AuditEvent(
                        id=row[0],
                        timestamp=datetime.fromisoformat(row[1]),
                        event_type=EventType(row[2]),
                        level=LogLevel(row[3]),
                        user_id=row[4],
                        session_id=row[5],
                        target_id=row[6],
                        workflow_id=row[7],
                        message=row[8],
                        details=json.loads(row[9]),
                        source_ip=row[10],
                        user_agent=row[11],
                        hash=row[12]
                    )
                
                return None
        
        except Exception as e:
            self.logger.error(f"Failed to retrieve event {event_id}: {e}")
            return None
    
    async def verify_event_integrity(self, event_id: str) -> bool:
        """Verify the integrity of an audit event"""
        try:
            event = await self.get_event(event_id)
            if not event:
                return False
            
            # Recalculate hash
            event_data = {
                "id": event.id,
                "timestamp": event.timestamp.isoformat(),
                "event_type": event.event_type.value,
                "level": event.level.value,
                "user_id": event.user_id,
                "session_id": event.session_id,
                "target_id": event.target_id,
                "workflow_id": event.workflow_id,
                "message": event.message,
                "details": event.details,
                "source_ip": event.source_ip,
                "user_agent": event.user_agent
            }
            
            calculated_hash = self._calculate_event_hash(event_data)
            return hmac.compare_digest(calculated_hash, event.hash)
        
        except Exception as e:
            self.logger.error(f"Failed to verify event integrity {event_id}: {e}")
            return False
    
    async def get_statistics(
        self,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None
    ) -> Dict[str, Any]:
        """Get audit statistics"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # Build time filter
                time_filter = ""
                params = []
                if start_time and end_time:
                    time_filter = "WHERE timestamp BETWEEN ? AND ?"
                    params = [start_time.isoformat(), end_time.isoformat()]
                elif start_time:
                    time_filter = "WHERE timestamp >= ?"
                    params = [start_time.isoformat()]
                elif end_time:
                    time_filter = "WHERE timestamp <= ?"
                    params = [end_time.isoformat()]
                
                # Total events
                cursor.execute(f"SELECT COUNT(*) FROM audit_events {time_filter}", params)
                total_events = cursor.fetchone()[0]
                
                # Events by type
                cursor.execute(f"""
                    SELECT event_type, COUNT(*) 
                    FROM audit_events {time_filter}
                    GROUP BY event_type
                """, params)
                events_by_type = dict(cursor.fetchall())
                
                # Events by level
                cursor.execute(f"""
                    SELECT level, COUNT(*) 
                    FROM audit_events {time_filter}
                    GROUP BY level
                """, params)
                events_by_level = dict(cursor.fetchall())
                
                # Events by user
                cursor.execute(f"""
                    SELECT user_id, COUNT(*) 
                    FROM audit_events {time_filter}
                    GROUP BY user_id
                    ORDER BY COUNT(*) DESC
                    LIMIT 10
                """, params)
                events_by_user = dict(cursor.fetchall())
                
                return {
                    "total_events": total_events,
                    "events_by_type": events_by_type,
                    "events_by_level": events_by_level,
                    "top_users": events_by_user,
                    "period": {
                        "start": start_time.isoformat() if start_time else None,
                        "end": end_time.isoformat() if end_time else None
                    }
                }
        
        except Exception as e:
            self.logger.error(f"Failed to get audit statistics: {e}")
            return {}
    
    async def export_events(
        self,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        format: str = "json"
    ) -> str:
        """Export audit events"""
        try:
            events = await self.get_events(
                start_time=start_time,
                end_time=end_time,
                limit=10000  # Large limit for export
            )
            
            if format == "json":
                return json.dumps([asdict(event) for event in events], indent=2, default=str)
            elif format == "csv":
                # Convert to CSV format
                csv_lines = ["timestamp,event_type,level,user_id,message,hash"]
                for event in events:
                    csv_lines.append(f"{event.timestamp},{event.event_type.value},{event.level.value},{event.user_id},\"{event.message}\",{event.hash}")
                return "\n".join(csv_lines)
            else:
                return str(events)
        
        except Exception as e:
            self.logger.error(f"Failed to export events: {e}")
            return ""
    
    async def cleanup_old_events(self, days: Optional[int] = None):
        """Clean up old audit events"""
        try:
            retention_days = days or self.retention_days
            cutoff_date = datetime.utcnow() - timedelta(days=retention_days)
            
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # Delete old events
                cursor.execute("DELETE FROM audit_events WHERE timestamp < ?", (cutoff_date.isoformat(),))
                deleted_count = cursor.rowcount
                
                conn.commit()
                
                self.logger.info(f"Cleaned up {deleted_count} old audit events")
                
                # Log the cleanup
                self.log_event(
                    event_type=EventType.SYSTEM_START,
                    level=LogLevel.INFO,
                    user_id="system",
                    message=f"Cleaned up {deleted_count} old audit events",
                    details={"retention_days": retention_days, "cutoff_date": cutoff_date.isoformat()}
                )
        
        except Exception as e:
            self.logger.error(f"Failed to cleanup old events: {e}")
    
    def close(self):
        """Close the audit logger"""
        try:
            self._log_system_event("Audit logger shutting down")
            self.logger.info("Audit logger closed")
        except Exception as e:
            self.logger.error(f"Failed to close audit logger: {e}")