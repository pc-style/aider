"""
Graph Database for Pentest AI

Manages targets, sessions, credentials, and relationships using Neo4j
for comprehensive pentest data management and analysis.
"""

import asyncio
import logging
import json
import os
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime
from enum import Enum
import neo4j
from neo4j import GraphDatabase
import networkx as nx


class NodeType(Enum):
    """Types of nodes in the graph"""
    TARGET = "Target"
    SESSION = "Session"
    WORKFLOW = "Workflow"
    VULNERABILITY = "Vulnerability"
    CREDENTIAL = "Credential"
    TOOL = "Tool"
    USER = "User"
    NETWORK = "Network"
    SERVICE = "Service"
    PORT = "Port"
    DOMAIN = "Domain"
    IP_ADDRESS = "IPAddress"
    CVE = "CVE"


class RelationshipType(Enum):
    """Types of relationships in the graph"""
    HAS_VULNERABILITY = "HAS_VULNERABILITY"
    HAS_CREDENTIAL = "HAS_CREDENTIAL"
    RUNS_ON = "RUNS_ON"
    CONNECTS_TO = "CONNECTS_TO"
    PART_OF = "PART_OF"
    BELONGS_TO = "BELONGS_TO"
    EXECUTES = "EXECUTES"
    DISCOVERS = "DISCOVERS"
    EXPLOITS = "EXPLOITS"
    ACCESSES = "ACCESSES"
    REFERENCES = "REFERENCES"


@dataclass
class GraphNode:
    """A node in the graph database"""
    id: str
    type: NodeType
    properties: Dict[str, Any]
    labels: List[str] = None


@dataclass
class GraphRelationship:
    """A relationship in the graph database"""
    id: str
    source_id: str
    target_id: str
    type: RelationshipType
    properties: Dict[str, Any] = None


@dataclass
class Target:
    """A pentest target"""
    id: str
    name: str
    type: str  # "domain", "ip", "network", "application"
    scope: List[str]
    status: str  # "active", "completed", "failed"
    created_at: datetime
    updated_at: datetime
    metadata: Dict[str, Any] = None


@dataclass
class Session:
    """A pentest session"""
    id: str
    target_id: str
    user_id: str
    start_time: datetime
    end_time: Optional[datetime]
    status: str  # "active", "completed", "failed"
    scope: List[str]
    tools_used: List[str]
    findings: List[str]
    metadata: Dict[str, Any] = None


@dataclass
class Vulnerability:
    """A discovered vulnerability"""
    id: str
    target_id: str
    session_id: str
    cve_id: Optional[str]
    title: str
    description: str
    severity: str  # "critical", "high", "medium", "low", "info"
    cvss_score: Optional[float]
    status: str  # "open", "confirmed", "exploited", "fixed"
    discovered_at: datetime
    exploited_at: Optional[datetime]
    metadata: Dict[str, Any] = None


@dataclass
class Credential:
    """A discovered credential"""
    id: str
    target_id: str
    session_id: str
    username: str
    password_hash: Optional[str]
    password_plain: Optional[str]
    service: str
    port: Optional[int]
    discovered_at: datetime
    is_valid: bool
    metadata: Dict[str, Any] = None


class GraphDatabase:
    """
    Neo4j-based graph database for pentest data management
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.logger = logging.getLogger(__name__)
        
        # Neo4j connection parameters
        self.uri = self.config.get("uri") or os.getenv("NEO4J_URI", "bolt://localhost:7687")
        self.user = self.config.get("user") or os.getenv("NEO4J_USER", "neo4j")
        self.password = self.config.get("password") or os.getenv("NEO4J_PASSWORD", "password")
        
        # Initialize Neo4j driver
        try:
            self.driver = GraphDatabase.driver(self.uri, auth=(self.user, self.password))
            self.logger.info("Neo4j driver initialized successfully")
        except Exception as e:
            self.logger.error(f"Failed to initialize Neo4j driver: {e}")
            raise
        
        # Initialize database schema
        self._initialize_schema()
    
    def _initialize_schema(self):
        """Initialize database schema with constraints and indexes"""
        try:
            with self.driver.session() as session:
                # Create constraints
                constraints = [
                    "CREATE CONSTRAINT target_id IF NOT EXISTS FOR (t:Target) REQUIRE t.id IS UNIQUE",
                    "CREATE CONSTRAINT session_id IF NOT EXISTS FOR (s:Session) REQUIRE s.id IS UNIQUE",
                    "CREATE CONSTRAINT workflow_id IF NOT EXISTS FOR (w:Workflow) REQUIRE w.id IS UNIQUE",
                    "CREATE CONSTRAINT vulnerability_id IF NOT EXISTS FOR (v:Vulnerability) REQUIRE v.id IS UNIQUE",
                    "CREATE CONSTRAINT credential_id IF NOT EXISTS FOR (c:Credential) REQUIRE c.id IS UNIQUE",
                    "CREATE CONSTRAINT cve_id IF NOT EXISTS FOR (cve:CVE) REQUIRE cve.id IS UNIQUE"
                ]
                
                for constraint in constraints:
                    session.run(constraint)
                
                # Create indexes
                indexes = [
                    "CREATE INDEX target_name IF NOT EXISTS FOR (t:Target) ON (t.name)",
                    "CREATE INDEX target_type IF NOT EXISTS FOR (t:Target) ON (t.type)",
                    "CREATE INDEX vulnerability_severity IF NOT EXISTS FOR (v:Vulnerability) ON (v.severity)",
                    "CREATE INDEX vulnerability_cve IF NOT EXISTS FOR (v:Vulnerability) ON (v.cve_id)",
                    "CREATE INDEX session_status IF NOT EXISTS FOR (s:Session) ON (s.status)",
                    "CREATE INDEX credential_service IF NOT EXISTS FOR (c:Credential) ON (c.service)"
                ]
                
                for index in indexes:
                    session.run(index)
                
                self.logger.info("Database schema initialized successfully")
        
        except Exception as e:
            self.logger.error(f"Failed to initialize database schema: {e}")
            raise
    
    async def create_target(self, target: Target) -> bool:
        """Create a new target"""
        try:
            with self.driver.session() as session:
                query = """
                CREATE (t:Target {
                    id: $id,
                    name: $name,
                    type: $type,
                    scope: $scope,
                    status: $status,
                    created_at: $created_at,
                    updated_at: $updated_at,
                    metadata: $metadata
                })
                """
                
                session.run(query, **asdict(target))
                
                self.logger.info(f"Created target: {target.name}")
                return True
        
        except Exception as e:
            self.logger.error(f"Failed to create target {target.name}: {e}")
            return False
    
    async def get_target(self, target_id: str) -> Optional[Target]:
        """Get a target by ID"""
        try:
            with self.driver.session() as session:
                query = "MATCH (t:Target {id: $target_id}) RETURN t"
                result = session.run(query, target_id=target_id)
                record = result.single()
                
                if record:
                    data = record["t"]
                    return Target(
                        id=data["id"],
                        name=data["name"],
                        type=data["type"],
                        scope=data["scope"],
                        status=data["status"],
                        created_at=datetime.fromisoformat(data["created_at"]),
                        updated_at=datetime.fromisoformat(data["updated_at"]),
                        metadata=data.get("metadata", {})
                    )
                
                return None
        
        except Exception as e:
            self.logger.error(f"Failed to get target {target_id}: {e}")
            return None
    
    async def update_target(self, target_id: str, updates: Dict[str, Any]) -> bool:
        """Update a target"""
        try:
            with self.driver.session() as session:
                set_clauses = []
                params = {"target_id": target_id}
                
                for key, value in updates.items():
                    set_clauses.append(f"t.{key} = ${key}")
                    params[key] = value
                
                set_clauses.append("t.updated_at = datetime()")
                
                query = f"""
                MATCH (t:Target {{id: $target_id}})
                SET {', '.join(set_clauses)}
                """
                
                session.run(query, **params)
                
                self.logger.info(f"Updated target: {target_id}")
                return True
        
        except Exception as e:
            self.logger.error(f"Failed to update target {target_id}: {e}")
            return False
    
    async def create_session(self, session: Session) -> bool:
        """Create a new session"""
        try:
            with self.driver.session() as session_obj:
                # Create session node
                query = """
                CREATE (s:Session {
                    id: $id,
                    target_id: $target_id,
                    user_id: $user_id,
                    start_time: $start_time,
                    end_time: $end_time,
                    status: $status,
                    scope: $scope,
                    tools_used: $tools_used,
                    findings: $findings,
                    metadata: $metadata
                })
                """
                
                session_obj.run(query, **asdict(session))
                
                # Create relationship to target
                rel_query = """
                MATCH (s:Session {id: $session_id})
                MATCH (t:Target {id: $target_id})
                CREATE (s)-[:BELONGS_TO]->(t)
                """
                
                session_obj.run(rel_query, session_id=session.id, target_id=session.target_id)
                
                self.logger.info(f"Created session: {session.id}")
                return True
        
        except Exception as e:
            self.logger.error(f"Failed to create session {session.id}: {e}")
            return False
    
    async def get_session(self, session_id: str) -> Optional[Session]:
        """Get a session by ID"""
        try:
            with self.driver.session() as session_obj:
                query = "MATCH (s:Session {id: $session_id}) RETURN s"
                result = session_obj.run(query, session_id=session_id)
                record = result.single()
                
                if record:
                    data = record["s"]
                    return Session(
                        id=data["id"],
                        target_id=data["target_id"],
                        user_id=data["user_id"],
                        start_time=datetime.fromisoformat(data["start_time"]),
                        end_time=datetime.fromisoformat(data["end_time"]) if data["end_time"] else None,
                        status=data["status"],
                        scope=data["scope"],
                        tools_used=data["tools_used"],
                        findings=data["findings"],
                        metadata=data.get("metadata", {})
                    )
                
                return None
        
        except Exception as e:
            self.logger.error(f"Failed to get session {session_id}: {e}")
            return None
    
    async def create_workflow(
        self,
        workflow_id: str,
        target: str,
        scope: List[str],
        workflow_type: str,
        steps: List[Any]
    ) -> bool:
        """Create a new workflow"""
        try:
            with self.driver.session() as session:
                query = """
                CREATE (w:Workflow {
                    id: $workflow_id,
                    target: $target,
                    scope: $scope,
                    workflow_type: $workflow_type,
                    steps: $steps,
                    status: 'pending',
                    created_at: datetime(),
                    updated_at: datetime()
                })
                """
                
                session.run(query, **{
                    "workflow_id": workflow_id,
                    "target": target,
                    "scope": scope,
                    "workflow_type": workflow_type,
                    "steps": [step.__dict__ for step in steps]
                })
                
                self.logger.info(f"Created workflow: {workflow_id}")
                return True
        
        except Exception as e:
            self.logger.error(f"Failed to create workflow {workflow_id}: {e}")
            return False
    
    async def get_workflow(self, workflow_id: str) -> Optional[Dict[str, Any]]:
        """Get a workflow by ID"""
        try:
            with self.driver.session() as session:
                query = "MATCH (w:Workflow {id: $workflow_id}) RETURN w"
                result = session.run(query, workflow_id=workflow_id)
                record = result.single()
                
                if record:
                    return record["w"]
                
                return None
        
        except Exception as e:
            self.logger.error(f"Failed to get workflow {workflow_id}: {e}")
            return None
    
    async def update_workflow_results(
        self,
        workflow_id: str,
        results: Dict[str, Any],
        status: str
    ) -> bool:
        """Update workflow results"""
        try:
            with self.driver.session() as session:
                query = """
                MATCH (w:Workflow {id: $workflow_id})
                SET w.results = $results,
                    w.status = $status,
                    w.updated_at = datetime()
                """
                
                session.run(query, workflow_id=workflow_id, results=results, status=status)
                
                self.logger.info(f"Updated workflow results: {workflow_id}")
                return True
        
        except Exception as e:
            self.logger.error(f"Failed to update workflow results {workflow_id}: {e}")
            return False
    
    async def create_vulnerability(self, vuln: Vulnerability) -> bool:
        """Create a new vulnerability"""
        try:
            with self.driver.session() as session:
                # Create vulnerability node
                query = """
                CREATE (v:Vulnerability {
                    id: $id,
                    target_id: $target_id,
                    session_id: $session_id,
                    cve_id: $cve_id,
                    title: $title,
                    description: $description,
                    severity: $severity,
                    cvss_score: $cvss_score,
                    status: $status,
                    discovered_at: $discovered_at,
                    exploited_at: $exploited_at,
                    metadata: $metadata
                })
                """
                
                session.run(query, **asdict(vuln))
                
                # Create relationships
                rel_queries = [
                    """
                    MATCH (v:Vulnerability {id: $vuln_id})
                    MATCH (t:Target {id: $target_id})
                    CREATE (t)-[:HAS_VULNERABILITY]->(v)
                    """,
                    """
                    MATCH (v:Vulnerability {id: $vuln_id})
                    MATCH (s:Session {id: $session_id})
                    CREATE (s)-[:DISCOVERS]->(v)
                    """
                ]
                
                for rel_query in rel_queries:
                    session.run(rel_query, vuln_id=vuln.id, target_id=vuln.target_id, session_id=vuln.session_id)
                
                # Create CVE relationship if CVE exists
                if vuln.cve_id:
                    cve_query = """
                    MATCH (v:Vulnerability {id: $vuln_id})
                    MERGE (cve:CVE {id: $cve_id})
                    CREATE (v)-[:REFERENCES]->(cve)
                    """
                    session.run(cve_query, vuln_id=vuln.id, cve_id=vuln.cve_id)
                
                self.logger.info(f"Created vulnerability: {vuln.id}")
                return True
        
        except Exception as e:
            self.logger.error(f"Failed to create vulnerability {vuln.id}: {e}")
            return False
    
    async def create_credential(self, cred: Credential) -> bool:
        """Create a new credential"""
        try:
            with self.driver.session() as session:
                # Create credential node
                query = """
                CREATE (c:Credential {
                    id: $id,
                    target_id: $target_id,
                    session_id: $session_id,
                    username: $username,
                    password_hash: $password_hash,
                    password_plain: $password_plain,
                    service: $service,
                    port: $port,
                    discovered_at: $discovered_at,
                    is_valid: $is_valid,
                    metadata: $metadata
                })
                """
                
                session.run(query, **asdict(cred))
                
                # Create relationships
                rel_queries = [
                    """
                    MATCH (c:Credential {id: $cred_id})
                    MATCH (t:Target {id: $target_id})
                    CREATE (t)-[:HAS_CREDENTIAL]->(c)
                    """,
                    """
                    MATCH (c:Credential {id: $cred_id})
                    MATCH (s:Session {id: $session_id})
                    CREATE (s)-[:DISCOVERS]->(c)
                    """
                ]
                
                for rel_query in rel_queries:
                    session.run(rel_query, cred_id=cred.id, target_id=cred.target_id, session_id=cred.session_id)
                
                self.logger.info(f"Created credential: {cred.id}")
                return True
        
        except Exception as e:
            self.logger.error(f"Failed to create credential {cred.id}: {e}")
            return False
    
    async def get_target_vulnerabilities(self, target_id: str) -> List[Vulnerability]:
        """Get all vulnerabilities for a target"""
        try:
            with self.driver.session() as session:
                query = """
                MATCH (t:Target {id: $target_id})-[:HAS_VULNERABILITY]->(v:Vulnerability)
                RETURN v
                ORDER BY v.severity DESC, v.discovered_at DESC
                """
                
                result = session.run(query, target_id=target_id)
                vulnerabilities = []
                
                for record in result:
                    data = record["v"]
                    vuln = Vulnerability(
                        id=data["id"],
                        target_id=data["target_id"],
                        session_id=data["session_id"],
                        cve_id=data.get("cve_id"),
                        title=data["title"],
                        description=data["description"],
                        severity=data["severity"],
                        cvss_score=data.get("cvss_score"),
                        status=data["status"],
                        discovered_at=datetime.fromisoformat(data["discovered_at"]),
                        exploited_at=datetime.fromisoformat(data["exploited_at"]) if data.get("exploited_at") else None,
                        metadata=data.get("metadata", {})
                    )
                    vulnerabilities.append(vuln)
                
                return vulnerabilities
        
        except Exception as e:
            self.logger.error(f"Failed to get vulnerabilities for target {target_id}: {e}")
            return []
    
    async def get_target_credentials(self, target_id: str) -> List[Credential]:
        """Get all credentials for a target"""
        try:
            with self.driver.session() as session:
                query = """
                MATCH (t:Target {id: $target_id})-[:HAS_CREDENTIAL]->(c:Credential)
                RETURN c
                ORDER BY c.discovered_at DESC
                """
                
                result = session.run(query, target_id=target_id)
                credentials = []
                
                for record in result:
                    data = record["c"]
                    cred = Credential(
                        id=data["id"],
                        target_id=data["target_id"],
                        session_id=data["session_id"],
                        username=data["username"],
                        password_hash=data.get("password_hash"),
                        password_plain=data.get("password_plain"),
                        service=data["service"],
                        port=data.get("port"),
                        discovered_at=datetime.fromisoformat(data["discovered_at"]),
                        is_valid=data["is_valid"],
                        metadata=data.get("metadata", {})
                    )
                    credentials.append(cred)
                
                return credentials
        
        except Exception as e:
            self.logger.error(f"Failed to get credentials for target {target_id}: {e}")
            return []
    
    async def search_targets(self, query: str, filters: Optional[Dict[str, Any]] = None) -> List[Target]:
        """Search targets with filters"""
        try:
            with self.driver.session() as session:
                base_query = "MATCH (t:Target)"
                where_clauses = []
                params = {}
                
                if query:
                    where_clauses.append("t.name CONTAINS $query OR t.type CONTAINS $query")
                    params["query"] = query
                
                if filters:
                    for key, value in filters.items():
                        if isinstance(value, list):
                            where_clauses.append(f"t.{key} IN ${key}")
                        else:
                            where_clauses.append(f"t.{key} = ${key}")
                        params[key] = value
                
                if where_clauses:
                    base_query += " WHERE " + " AND ".join(where_clauses)
                
                base_query += " RETURN t ORDER BY t.updated_at DESC"
                
                result = session.run(base_query, **params)
                targets = []
                
                for record in result:
                    data = record["t"]
                    target = Target(
                        id=data["id"],
                        name=data["name"],
                        type=data["type"],
                        scope=data["scope"],
                        status=data["status"],
                        created_at=datetime.fromisoformat(data["created_at"]),
                        updated_at=datetime.fromisoformat(data["updated_at"]),
                        metadata=data.get("metadata", {})
                    )
                    targets.append(target)
                
                return targets
        
        except Exception as e:
            self.logger.error(f"Failed to search targets: {e}")
            return []
    
    async def get_attack_paths(self, target_id: str, max_depth: int = 3) -> List[List[str]]:
        """Get potential attack paths to a target"""
        try:
            with self.driver.session() as session:
                query = """
                MATCH path = (start:Target)-[:CONNECTS_TO*1..$max_depth]->(target:Target {id: $target_id})
                WHERE start.id <> $target_id
                RETURN path
                ORDER BY length(path)
                """
                
                result = session.run(query, target_id=target_id, max_depth=max_depth)
                paths = []
                
                for record in result:
                    path = record["path"]
                    path_nodes = [node["id"] for node in path.nodes]
                    paths.append(path_nodes)
                
                return paths
        
        except Exception as e:
            self.logger.error(f"Failed to get attack paths for target {target_id}: {e}")
            return []
    
    async def get_risk_score(self, target_id: str) -> float:
        """Calculate risk score for a target based on vulnerabilities and credentials"""
        try:
            with self.driver.session() as session:
                query = """
                MATCH (t:Target {id: $target_id})-[:HAS_VULNERABILITY]->(v:Vulnerability)
                WITH t, collect(v) as vulns
                OPTIONAL MATCH (t)-[:HAS_CREDENTIAL]->(c:Credential)
                WITH t, vulns, collect(c) as creds
                RETURN t, vulns, creds
                """
                
                result = session.run(query, target_id=target_id)
                record = result.single()
                
                if not record:
                    return 0.0
                
                vulns = record["vulns"]
                creds = record["creds"]
                
                # Calculate risk score
                risk_score = 0.0
                
                # Vulnerability scoring
                severity_weights = {
                    "critical": 10.0,
                    "high": 7.5,
                    "medium": 5.0,
                    "low": 2.5,
                    "info": 1.0
                }
                
                for vuln in vulns:
                    severity = vuln["severity"]
                    weight = severity_weights.get(severity, 1.0)
                    risk_score += weight
                
                # Credential scoring
                for cred in creds:
                    if cred["is_valid"]:
                        risk_score += 5.0
                    else:
                        risk_score += 1.0
                
                # Normalize to 0-100 scale
                risk_score = min(100.0, risk_score)
                
                return risk_score
        
        except Exception as e:
            self.logger.error(f"Failed to calculate risk score for target {target_id}: {e}")
            return 0.0
    
    async def export_graph(self, format: str = "json") -> str:
        """Export the entire graph"""
        try:
            with self.driver.session() as session:
                query = """
                MATCH (n)
                OPTIONAL MATCH (n)-[r]->(m)
                RETURN n, r, m
                """
                
                result = session.run(query)
                graph_data = {
                    "nodes": [],
                    "relationships": []
                }
                
                nodes_seen = set()
                rels_seen = set()
                
                for record in result:
                    # Add source node
                    if record["n"] and record["n"]["id"] not in nodes_seen:
                        graph_data["nodes"].append({
                            "id": record["n"]["id"],
                            "labels": list(record["n"].labels),
                            "properties": dict(record["n"])
                        })
                        nodes_seen.add(record["n"]["id"])
                    
                    # Add target node
                    if record["m"] and record["m"]["id"] not in nodes_seen:
                        graph_data["nodes"].append({
                            "id": record["m"]["id"],
                            "labels": list(record["m"].labels),
                            "properties": dict(record["m"])
                        })
                        nodes_seen.add(record["m"]["id"])
                    
                    # Add relationship
                    if record["r"] and record["r"]["id"] not in rels_seen:
                        graph_data["relationships"].append({
                            "id": record["r"]["id"],
                            "type": record["r"]["type"],
                            "start_node": record["r"]["start_node"],
                            "end_node": record["r"]["end_node"],
                            "properties": dict(record["r"])
                        })
                        rels_seen.add(record["r"]["id"])
                
                if format == "json":
                    return json.dumps(graph_data, indent=2, default=str)
                else:
                    return str(graph_data)
        
        except Exception as e:
            self.logger.error(f"Failed to export graph: {e}")
            return ""
    
    async def close(self):
        """Close the database connection"""
        try:
            self.driver.close()
            self.logger.info("Database connection closed")
        except Exception as e:
            self.logger.error(f"Failed to close database connection: {e}")