"""
Container Manager for Pentest AI

Manages Docker containers for sandboxed execution of pentest tools
and workflows with proper isolation and security controls.
"""

import asyncio
import logging
import json
import os
import tempfile
import shutil
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from enum import Enum
import docker
from docker.errors import DockerException, ContainerError
import aiofiles


class ContainerStatus(Enum):
    """Container status"""
    CREATED = "created"
    RUNNING = "running"
    STOPPED = "stopped"
    REMOVED = "removed"
    ERROR = "error"


@dataclass
class ContainerConfig:
    """Configuration for a container"""
    name: str
    image: str
    command: Optional[List[str]] = None
    environment: Optional[Dict[str, str]] = None
    volumes: Optional[Dict[str, Dict[str, str]]] = None
    ports: Optional[Dict[str, str]] = None
    network_mode: Optional[str] = None
    memory_limit: Optional[str] = None
    cpu_limit: Optional[float] = None
    security_opts: Optional[List[str]] = None
    cap_drop: Optional[List[str]] = None
    read_only: bool = False
    auto_remove: bool = True
    timeout: int = 300


@dataclass
class ContainerResult:
    """Result of container execution"""
    container_id: str
    status: ContainerStatus
    exit_code: Optional[int]
    stdout: str
    stderr: str
    logs: str
    start_time: Optional[str] = None
    end_time: Optional[str] = None
    error: Optional[str] = None


class ContainerManager:
    """
    Manages Docker containers for sandboxed pentest tool execution
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.logger = logging.getLogger(__name__)
        
        # Initialize Docker client
        try:
            self.docker_client = docker.from_env()
            self.logger.info("Docker client initialized successfully")
        except DockerException as e:
            self.logger.error(f"Failed to initialize Docker client: {e}")
            raise
        
        # Container registry
        self.containers: Dict[str, ContainerResult] = {}
        
        # Predefined tool images
        self.tool_images = {
            "nmap": "nmap/nmap:latest",
            "metasploit": "metasploitframework/metasploit-framework:latest",
            "burp": "portswigger/burp-rest-api:latest",
            "wireshark": "linuxserver/wireshark:latest",
            "sqlmap": "sqlmap/sqlmap:latest",
            "nikto": "hysnsec/nikto:latest",
            "gobuster": "gobuster/gobuster:latest",
            "hydra": "vanhauserthc/thc-hydra:latest",
            "john": "openwall/john:latest",
            "hashcat": "hashcat/hashcat:latest"
        }
        
        # Initialize base images
        self._initialize_base_images()
    
    def _initialize_base_images(self):
        """Initialize base images for pentest tools"""
        self.logger.info("Initializing base images...")
        
        for tool, image in self.tool_images.items():
            try:
                # Check if image exists
                self.docker_client.images.get(image)
                self.logger.info(f"Image {image} already available")
            except docker.errors.ImageNotFound:
                self.logger.info(f"Pulling image {image}...")
                try:
                    self.docker_client.images.pull(image)
                    self.logger.info(f"Successfully pulled {image}")
                except Exception as e:
                    self.logger.warning(f"Failed to pull {image}: {e}")
    
    async def create_container(
        self,
        name: str,
        image: str,
        command: Optional[List[str]] = None,
        environment: Optional[Dict[str, str]] = None,
        volumes: Optional[Dict[str, Dict[str, str]]] = None,
        ports: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> str:
        """
        Create a new container
        
        Args:
            name: Container name
            image: Docker image to use
            command: Command to run
            environment: Environment variables
            volumes: Volume mappings
            ports: Port mappings
            **kwargs: Additional container options
        
        Returns:
            Container ID
        """
        
        try:
            # Create temporary directory for container data
            temp_dir = tempfile.mkdtemp(prefix=f"pentest_{name}_")
            
            # Prepare container configuration
            container_config = ContainerConfig(
                name=name,
                image=image,
                command=command,
                environment=environment or {},
                volumes=volumes or {},
                ports=ports or {},
                **kwargs
            )
            
            # Add security options
            if container_config.security_opts is None:
                container_config.security_opts = [
                    "no-new-privileges",
                    "seccomp=unconfined"
                ]
            
            if container_config.cap_drop is None:
                container_config.cap_drop = [
                    "ALL"
                ]
            
            # Create container
            container = self.docker_client.containers.run(
                image=container_config.image,
                command=container_config.command,
                environment=container_config.environment,
                volumes=container_config.volumes,
                ports=container_config.ports,
                network_mode=container_config.network_mode,
                mem_limit=container_config.memory_limit,
                cpu_quota=int(container_config.cpu_limit * 100000) if container_config.cpu_limit else None,
                security_opt=container_config.security_opts,
                cap_drop=container_config.cap_drop,
                read_only=container_config.read_only,
                auto_remove=container_config.auto_remove,
                detach=True,
                name=container_config.name
            )
            
            # Store container result
            container_result = ContainerResult(
                container_id=container.id,
                status=ContainerStatus.CREATED,
                exit_code=None,
                stdout="",
                stderr="",
                logs=""
            )
            
            self.containers[container.id] = container_result
            
            self.logger.info(f"Created container {container.id} ({name})")
            
            return container.id
        
        except Exception as e:
            self.logger.error(f"Failed to create container {name}: {e}")
            raise
    
    async def start_container(self, container_id: str) -> bool:
        """Start a container"""
        try:
            container = self.docker_client.containers.get(container_id)
            container.start()
            
            # Update status
            if container_id in self.containers:
                self.containers[container_id].status = ContainerStatus.RUNNING
            
            self.logger.info(f"Started container {container_id}")
            return True
        
        except Exception as e:
            self.logger.error(f"Failed to start container {container_id}: {e}")
            return False
    
    async def stop_container(self, container_id: str, timeout: int = 10) -> bool:
        """Stop a container"""
        try:
            container = self.docker_client.containers.get(container_id)
            container.stop(timeout=timeout)
            
            # Update status
            if container_id in self.containers:
                self.containers[container_id].status = ContainerStatus.STOPPED
            
            self.logger.info(f"Stopped container {container_id}")
            return True
        
        except Exception as e:
            self.logger.error(f"Failed to stop container {container_id}: {e}")
            return False
    
    async def remove_container(self, container_id: str) -> bool:
        """Remove a container"""
        try:
            container = self.docker_client.containers.get(container_id)
            container.remove(force=True)
            
            # Update status
            if container_id in self.containers:
                self.containers[container_id].status = ContainerStatus.REMOVED
            
            self.logger.info(f"Removed container {container_id}")
            return True
        
        except Exception as e:
            self.logger.error(f"Failed to remove container {container_id}: {e}")
            return False
    
    async def execute_command(
        self,
        container_id: str,
        command: List[str],
        timeout: int = 300
    ) -> ContainerResult:
        """
        Execute a command in a running container
        
        Args:
            container_id: Container ID
            command: Command to execute
            timeout: Execution timeout in seconds
        
        Returns:
            ContainerResult with execution results
        """
        
        try:
            container = self.docker_client.containers.get(container_id)
            
            # Execute command
            exec_result = container.exec_run(
                cmd=command,
                timeout=timeout
            )
            
            # Update container result
            if container_id in self.containers:
                self.containers[container_id].exit_code = exec_result.exit_code
                self.containers[container_id].stdout = exec_result.output.decode('utf-8')
                self.containers[container_id].stderr = ""
            
            result = ContainerResult(
                container_id=container_id,
                status=ContainerStatus.RUNNING,
                exit_code=exec_result.exit_code,
                stdout=exec_result.output.decode('utf-8'),
                stderr="",
                logs=""
            )
            
            self.logger.info(f"Executed command in container {container_id}: {command}")
            return result
        
        except Exception as e:
            self.logger.error(f"Failed to execute command in container {container_id}: {e}")
            
            result = ContainerResult(
                container_id=container_id,
                status=ContainerStatus.ERROR,
                exit_code=None,
                stdout="",
                stderr="",
                logs="",
                error=str(e)
            )
            
            return result
    
    async def run_tool(
        self,
        tool_name: str,
        command: List[str],
        environment: Optional[Dict[str, str]] = None,
        volumes: Optional[Dict[str, Dict[str, str]]] = None,
        timeout: int = 300
    ) -> ContainerResult:
        """
        Run a pentest tool in a sandboxed container
        
        Args:
            tool_name: Name of the tool to run
            command: Command to execute
            environment: Environment variables
            volumes: Volume mappings
            timeout: Execution timeout
        
        Returns:
            ContainerResult with tool execution results
        """
        
        if tool_name not in self.tool_images:
            raise ValueError(f"Unknown tool: {tool_name}")
        
        image = self.tool_images[tool_name]
        container_name = f"pentest_{tool_name}_{os.getpid()}_{id(command)}"
        
        try:
            # Create container
            container_id = await self.create_container(
                name=container_name,
                image=image,
                command=command,
                environment=environment or {},
                volumes=volumes or {},
                memory_limit="512m",
                cpu_limit=0.5,
                read_only=True
            )
            
            # Start container
            await self.start_container(container_id)
            
            # Wait for completion
            container = self.docker_client.containers.get(container_id)
            container.wait(timeout=timeout)
            
            # Get logs
            logs = container.logs().decode('utf-8')
            
            # Get container info
            container_info = container.attrs
            
            # Create result
            result = ContainerResult(
                container_id=container_id,
                status=ContainerStatus.STOPPED,
                exit_code=container_info['State']['ExitCode'],
                stdout=logs,
                stderr="",
                logs=logs,
                start_time=container_info['State']['StartedAt'],
                end_time=container_info['State']['FinishedAt']
            )
            
            # Clean up
            await self.remove_container(container_id)
            
            self.logger.info(f"Completed tool execution: {tool_name}")
            return result
        
        except Exception as e:
            self.logger.error(f"Failed to run tool {tool_name}: {e}")
            
            result = ContainerResult(
                container_id="",
                status=ContainerStatus.ERROR,
                exit_code=None,
                stdout="",
                stderr="",
                logs="",
                error=str(e)
            )
            
            return result
    
    async def run_nmap_scan(
        self,
        target: str,
        scan_type: str = "basic",
        ports: Optional[str] = None,
        output_file: Optional[str] = None
    ) -> ContainerResult:
        """Run nmap scan in container"""
        
        # Prepare command
        command = ["nmap"]
        
        if scan_type == "basic":
            command.extend(["-sV", "-sC"])
        elif scan_type == "comprehensive":
            command.extend(["-sS", "-sV", "-sC", "-A", "-O"])
        elif scan_type == "stealth":
            command.extend(["-sS", "-sV", "--version-intensity", "5"])
        
        if ports:
            command.extend(["-p", ports])
        
        if output_file:
            command.extend(["-oN", "/output/scan.xml"])
        
        command.append(target)
        
        # Prepare volumes
        volumes = {}
        if output_file:
            volumes[os.path.dirname(output_file)] = {
                "bind": "/output",
                "mode": "rw"
            }
        
        return await self.run_tool("nmap", command, volumes=volumes)
    
    async def run_sqlmap_scan(
        self,
        target: str,
        level: int = 1,
        risk: int = 1,
        output_file: Optional[str] = None
    ) -> ContainerResult:
        """Run sqlmap scan in container"""
        
        command = [
            "sqlmap",
            "-u", target,
            "--level", str(level),
            "--risk", str(risk),
            "--batch",
            "--random-agent"
        ]
        
        if output_file:
            command.extend(["--output-dir", "/output"])
        
        volumes = {}
        if output_file:
            volumes[os.path.dirname(output_file)] = {
                "bind": "/output",
                "mode": "rw"
            }
        
        return await self.run_tool("sqlmap", command, volumes=volumes)
    
    async def run_nikto_scan(
        self,
        target: str,
        output_file: Optional[str] = None
    ) -> ContainerResult:
        """Run nikto scan in container"""
        
        command = ["nikto", "-h", target]
        
        if output_file:
            command.extend(["-o", "/output/nikto.txt"])
        
        volumes = {}
        if output_file:
            volumes[os.path.dirname(output_file)] = {
                "bind": "/output",
                "mode": "rw"
            }
        
        return await self.run_tool("nikto", command, volumes=volumes)
    
    async def run_gobuster_scan(
        self,
        target: str,
        wordlist: str = "/usr/share/wordlists/dirb/common.txt",
        scan_type: str = "dir",
        output_file: Optional[str] = None
    ) -> ContainerResult:
        """Run gobuster scan in container"""
        
        command = ["gobuster", scan_type, "-u", target, "-w", wordlist]
        
        if output_file:
            command.extend(["-o", "/output/gobuster.txt"])
        
        volumes = {}
        if output_file:
            volumes[os.path.dirname(output_file)] = {
                "bind": "/output",
                "mode": "rw"
            }
        
        return await self.run_tool("gobuster", command, volumes=volumes)
    
    async def get_container_status(self, container_id: str) -> Optional[ContainerStatus]:
        """Get container status"""
        try:
            container = self.docker_client.containers.get(container_id)
            state = container.attrs['State']['Status']
            
            if state == 'created':
                return ContainerStatus.CREATED
            elif state == 'running':
                return ContainerStatus.RUNNING
            elif state == 'exited':
                return ContainerStatus.STOPPED
            else:
                return ContainerStatus.ERROR
        
        except Exception as e:
            self.logger.error(f"Failed to get container status {container_id}: {e}")
            return None
    
    async def list_containers(self) -> List[Dict[str, Any]]:
        """List all containers"""
        try:
            containers = self.docker_client.containers.list(all=True)
            return [
                {
                    "id": container.id,
                    "name": container.name,
                    "status": container.status,
                    "image": container.image.tags[0] if container.image.tags else container.image.id
                }
                for container in containers
            ]
        except Exception as e:
            self.logger.error(f"Failed to list containers: {e}")
            return []
    
    async def cleanup_containers(self) -> int:
        """Clean up all pentest containers"""
        try:
            containers = self.docker_client.containers.list(
                filters={"name": "pentest_"}
            )
            
            count = 0
            for container in containers:
                try:
                    container.remove(force=True)
                    count += 1
                except Exception as e:
                    self.logger.warning(f"Failed to remove container {container.id}: {e}")
            
            self.logger.info(f"Cleaned up {count} containers")
            return count
        
        except Exception as e:
            self.logger.error(f"Failed to cleanup containers: {e}")
            return 0
    
    async def get_container_logs(self, container_id: str, tail: int = 100) -> str:
        """Get container logs"""
        try:
            container = self.docker_client.containers.get(container_id)
            logs = container.logs(tail=tail).decode('utf-8')
            return logs
        except Exception as e:
            self.logger.error(f"Failed to get logs for container {container_id}: {e}")
            return ""
    
    async def get_container_stats(self, container_id: str) -> Optional[Dict[str, Any]]:
        """Get container resource usage statistics"""
        try:
            container = self.docker_client.containers.get(container_id)
            stats = container.stats(stream=False)
            
            # Calculate CPU usage
            cpu_delta = stats['cpu_stats']['cpu_usage']['total_usage'] - \
                       stats['precpu_stats']['cpu_usage']['total_usage']
            system_delta = stats['cpu_stats']['system_cpu_usage'] - \
                          stats['precpu_stats']['system_cpu_usage']
            
            cpu_percent = 0.0
            if system_delta > 0:
                cpu_percent = (cpu_delta / system_delta) * len(stats['cpu_stats']['cpu_usage']['percpu_usage']) * 100.0
            
            # Calculate memory usage
            memory_usage = stats['memory_stats']['usage']
            memory_limit = stats['memory_stats']['limit']
            memory_percent = (memory_usage / memory_limit) * 100.0
            
            return {
                "cpu_percent": cpu_percent,
                "memory_usage": memory_usage,
                "memory_limit": memory_limit,
                "memory_percent": memory_percent,
                "network_rx": stats['networks']['eth0']['rx_bytes'],
                "network_tx": stats['networks']['eth0']['tx_bytes']
            }
        
        except Exception as e:
            self.logger.error(f"Failed to get stats for container {container_id}: {e}")
            return None